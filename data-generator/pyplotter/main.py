#!/usr/bin/env python3

#
# Program for plotting various information used as backtest source and also
# information generated by backtest, for better visual analysis.
#
# For reference, see
# /home/tomar/exploits/Programming/Python/finplot/finplot/finplot/examples/analyze.py
# and other examples in finplot/examples
#

import os
import sys
import importlib
import pandas as pd
import numpy as np
import finplot as fplt
from PyQt6.QtWidgets import QComboBox, QCheckBox, QWidget, QGridLayout, QPushButton
import pyqtgraph as pg

import config as cfg
from helpers import *

# This should match the definition of INVALID_DOUBLE in engine/util.h
INVALID_DOUBLE = 999999999.99

df = None
df1D = None
cpanel = None
layout = None
combobox_index = None
combobox_type = None
# Various axes.
axc = None
axv = None
ax1 = None
ax2 = None
ax3 = None
rsi_period = None
hide_legend = True
saved_hide_legend = False
clear_all = False
showgenorders = False
showenteredorders = False
showskippedorders = False
show200dma = False
show_full_timerange = False
plotting_intraday = None

def is_intraday():
        ''' Does df correspond to intraday or delivery data?
        '''
        assert(cfg.analytics_csvfile is not None)
        assert(plotting_intraday is not None)
        return plotting_intraday

def m2d(m):
        ''' Convert the given month value to days equivalent, used for
            deciding aggregate column names.
            Ref pyprocess which originally defines this mapping.
            The basic idea is that we have 21/22 days in a trading month
            since our historical data doesn't include Sat/Sun.
        '''
        assert(m >= 0.1 and m <= 12)
        if m >= 1:
                m2d = [0, 21, 43, 64, 86, 107, 129, 151, 173, 194, 216, 237, 260]
                return m2d[m]
        else:
                return int(m*31)

def get_titlebar():
        if cfg.analytics_csvfile is not None:
                return ("%s %s (%s) [%s - %s]" %
                                (cfg.symbol, cfg.cdlsz, cfg.strategy_selection,
                                 cfg.starttick, cfg.endtick))
        else:
                return ("%s %s" % (cfg.symbol, cfg.cdlsz))

def get_rowcount():
        ''' Scan the header line from the csv file and return the number of rows
            in the file.
            Note: This is unused.
        '''
        with open(cfg.csvfile, "r") as csvfh:
                #
                # First line is the header. Sample header line is like,
                # INDEX:38100:<double>,Date:38100:<string>,Open:38100:<double>,...
                #
                header = csvfh.readline().strip()
                columns = header.split(',')
                assert(len(columns) > 10)
                #
                # First column is the INDEX column, like
                # INDEX:38100:<double>
                #
                tokens = columns[0].split(':')
                assert(len(tokens) == 3)
                assert(tokens[0] == 'INDEX')
                assert(tokens[2] == 'double')

                return int(tokens[1])

def init_df1D():
        ''' Initialize the 1D dataframe by reading it from final.1D.csv,
            filtering required columns and upsampling it to cfg.cdlsz.
        '''
        global df1D

        #
        # We should be called only for "cdlsz != 1D", which is indicated by
        # cfg.csvfile_1D containing the 1D csv file's path.
        #
        assert(cfg.csvfile_1D is not None)
        assert(cfg.cdlsz != '1D')

        with open(cfg.csvfile_1D, "r") as csvfh:
                #
                # First line is the header. Sample header line is like,
                # INDEX:38100:<double>,Date:38100:<string>,Open:38100:<double>,...
                #
                header = csvfh.readline().strip()
                columns = header.split(',')
                #
                # Though we can have more columns, just do a basic sanity
                # check to ensure we are looking at the correct csv.
                #
                assert(len(columns) > 40)
                #
                # Rename all columns removing the size and type.
                # Date:38100:<string> -> Date
                #
                column_rename_dict = {}
                for col in columns:
                        tokens = col.split(':')
                        # INDEX -> Epoch.
                        new_name = tokens[0] if tokens[0] != "INDEX" else "epoch"
                        column_rename_dict[col] = new_name.lower()

        df1D = pd.read_csv(cfg.csvfile_1D, index_col=1, header=0, parse_dates=True)
        df1D.index.rename("time", inplace=True)
        df1D.rename(columns=column_rename_dict, inplace=True)

        #
        # If show_full_timerange is not set, drop all rows outside
        # [starttick, endtick].
        #
        if not show_full_timerange:
                mask = ((df1D.index >= np.datetime64(cfg.starttick)) &
                        (df1D.index <= np.datetime64(cfg.endtick)))
                df1D = df1D.loc[mask]

        #
        # w/o this finplot doesn't show the time correctly when hovering.
        #
        df1D = df1D.tz_localize('Asia/Kolkata')

        #
        # Drop columns which have all 0 rows.
        # Note that 0 is not a valid value for any of our columns, since they
        # mostly represent price or quantity and 0 is not interesting for
        # both.
        #
        # Note: Unlike the analytics_csvfile, csvfile_1D won't have any
        #       columns with all 0's, this is just for completeness.
        #
        df1D = df1D.replace(0, np.nan).dropna(axis=1, how="all")

        #
        # Collect all the columns that we want from the 1D dataframe,
        # upsampled to cfg.cdlsz.
        # TODO: Add any column that you want to upsample and would like to
        #       plot.
        #
        # Note: Don't upsample the entire 1D dataframe as it consumes lot of
        #       memory.
        #
        df1D = df1D[['50-sma', '100-sma', '200-sma', '3-vsma']].resample(cfg.cdlsz).ffill()
        return

def get_df():
        ''' Parse the csv and return a dataframe populate from it.
            It'll prep the csv so that it can be used by plotter, f.e., it
            renames the OHLCV columns to the lower case "open", "high", "low",
            "close" and "volume", sets the data column as the index, sets the
            timezone to Indian Standar Time, etc.
        '''
        with open(cfg.csvfile, "r") as csvfh:
                #
                # First line is the header. Sample header line is like,
                # INDEX:38100:<double>,Date:38100:<string>,Open:38100:<double>,...
                #
                header = csvfh.readline().strip()
                columns = header.split(',')
                #
                # Though we can have more columns, just do a basic sanity
                # check to ensure we are looking at the correct csv.
                #
                assert(len(columns) > 30)
                #
                # Rename all columns removing the size and type.
                # Date:38100:<string> -> Date
                #
                column_rename_dict = {}
                for col in columns:
                        tokens = col.split(':')
                        # INDEX -> Epoch.
                        new_name = tokens[0] if tokens[0] != "INDEX" else "epoch"
                        column_rename_dict[col] = new_name.lower()

        #
        # Column#1 is the Date column, that's our index column.
        # It's in IST timezone.
        #
        df = pd.read_csv(cfg.csvfile, index_col=1, header=0, parse_dates=True)
        df.index.rename("time", inplace=True)
        df.rename(columns=column_rename_dict, inplace=True)

        #
        # Add columns from analytics_csvfile if present.
        #
        if cfg.analytics_csvfile is not None:
                df_a = pd.read_csv(cfg.analytics_csvfile, index_col=0, header=0,
                                   parse_dates=True)

                #
                # Analytics candle size must match backtester's candle size.
                #
                if len(df) != len(df_a):
                        print("Analytics csv file has %d rows while the candle csv has %d rows. Please make sure that 'cdlsz' value is set correctly in the json config" % (len(df_a), len(df)))
                        sys.exit(-2)

                #
                # *All* the analytics columns.
                # Some of them may not be present for delivery or intraday.
                #
                columns_analytics = [
                        'pvalue', 'funds', 'investible', 'dtrend',
                        'buy_g', 'sell_g',
                        'buy_m', 'sell_m',
                        'buy_p', 'sell_p',
                        'buy_q', 'sell_q',
                        'buy_tq',
                        'buy_avgp',
                        'buy_s_ro', 'sell_s_ro',
                        'buy_s_fo', 'sell_s_fo',
                        'buy_s_if','sell_s_if',
                        'buy_s_cd','sell_s_cd',
                        'exit_p', 'exit_l', 'exit_db',
                        'pl_p', 'pl_l', 'pl_p_aso', 'pl_l_aso',
                        'enter', 'bullishness'
                ]

                #
                # Following are mandatory columns present for both intraday
                # and delivery strategies.
                #
                assert('pvalue' in df_a.columns)
                assert('funds' in df_a.columns)
                assert('investible' in df_a.columns)
                assert('dtrend' in df_a.columns)
                assert('buy_g' in df_a.columns)
                assert('sell_g' in df_a.columns)
                assert('buy_s_ro' in df_a.columns)
                assert('sell_s_ro' in df_a.columns)
                assert('buy_s_fo' in df_a.columns)
                assert('sell_s_fo' in df_a.columns)
                assert('buy_s_if' in df_a.columns)
                assert('sell_s_if' in df_a.columns)
                assert('buy_s_cd' in df_a.columns)
                assert('sell_s_cd' in df_a.columns)
                assert('buy_p' in df_a.columns)
                assert('sell_p' in df_a.columns)
                #
                # These would not be present unless Strategy supports
                # averaging (buy more if price falls further).
                #
                #assert('buy_tq' in df_a.columns)
                #assert('buy_avgp' in df_a.columns)
                assert('buy_m' in df_a.columns)
                assert('sell_m' in df_a.columns)
                assert('buy_q' in df_a.columns)
                assert('sell_q' in df_a.columns)
                assert('exit_p' in df_a.columns)
                assert('exit_l' in df_a.columns)
                assert('pl_p' in df_a.columns)
                assert('pl_l' in df_a.columns)

                #
                # backtester uses INVALID_DOUBLE to mark "unfilled" values,
                # replace it with NaN o/w it increases the display scale
                # causing valid price/quantity values to appear very small.
                #
                # XXX Watchout if python fails to match all INVALID_DOUBLE
                #     values due to floating point precision issues.
                #
                for ca in columns_analytics:
                        if ca in df_a.columns:
                                df[ca] = df_a[ca].replace(INVALID_DOUBLE, np.nan).to_numpy()

        #
        # Drop columns which have all NaN's.
        # See INVALID_DOUBLE replaced with NaN's above.
        #
        # These are the analytics columns which do not have any valid row.
        # Common ones are the columns for various "orders skipped" types,
        # f.e. buy_s_ro, sell_s_ro, etc.
        #
        df = df.dropna(axis=1, how="all")

        #
        # If show_full_timerange is not set, drop all rows outside
        # [starttick, endtick].
        #
        if not show_full_timerange:
                mask = ((df.index >= np.datetime64(cfg.starttick)) &
                        (df.index <= np.datetime64(cfg.endtick)))
                df = df.loc[mask]

        #
        # w/o this finplot doesn't show the time correctly when hovering.
        #
        df = df.tz_localize('Asia/Kolkata')

        #
        # Before dropping all-0 columns, set plotting_intraday.
        #
        global plotting_intraday
        if 'pl_p_aso' in df.columns:
                # Ensure all other intraday columns are present.
                assert('pl_l_aso' in df.columns)
                plotting_intraday = True
        else:
                # Ensure all other delivery columns are present.
                assert('exit_db' in df.columns)
                plotting_intraday = False

        #
        # Reload the 1D dataframe.
        # We need to refresh 1D df too since user may have changed the
        # analyze_stock.
        #
        if cfg.csvfile_1D is not None:
                init_df1D()

        #
        # Add upsampled columns from the 1D dataframe.
        # These can be used to print columns from 1D dataframe alongside the
        # other cdlsz sized plots. This is useful f.e., if we want to plot say
        # 200DMA on a 15Min candle chart.
        #
        # Note that when columns from 1D dataframe are copied to df they are
        # renamed with 1D_ prepended, and that's how it must be used by code
        # using it.
        #
        if cfg.csvfile_1D is not None:
                df['1D_50-sma']  = df1D['50-sma']
                df['1D_100-sma'] = df1D['100-sma']
                df['1D_200-sma'] = df1D['200-sma']
                #
                # Daily volume when plotted on intraday candles must be scaled
                # down appropriately. We have 375 minutes in a day so daily
                # volume corresponds to 375 minutes of trading time. To get
                # correct volume for say 15Min we need to divide volume by
                # 375/15=25.
                #
                divisor = 1
                if pd.Timedelta(cfg.cdlsz) < pd.Timedelta("375Min"):
                        divisor = pd.Timedelta("375Min") / pd.Timedelta(cfg.cdlsz)
                df['1D_3-vsma'] = df1D['3-vsma'].div(divisor)

        return df

def plot_candles(ax):
        ''' This plots the first (topmost) axis, with candles and other
            data that is easier correlated with the price in the same axis.

            Note: Don't plot data which has different range than the price,
                  else the y-axis might become skewed.
        '''
        #df[['open','close','high','low']].plot(ax=ax, kind='candle')
        candles = fplt.candlestick_ochl(df[['open','close','high','low']], ax=ax)
        # Change bear candle color to light red, to make the exit 'x' visible
        candles.colors.update(dict(bear_body='#fa8'))

        #if '5-sma' in df.columns:
        #        df[['5-sma']].plot(ax=ax, color='blue', legend='5-sma')
        #if '10-sma' in df.columns:
        #        df[['10-sma']].plot(ax=ax, color='pink', legend='10-sma')
        #if '20-sma' in df.columns:
        #        df[['20-sma']].plot(ax=ax, color='magenta', legend='20-sma')

        #if '1D_50-sma' in df.columns:
        #        df[['1D_50-sma']].plot(ax=ax, color='red', legend='50DMA')
        #if '1D_100-sma' in df.columns:
        #        df[['1D_100-sma']].plot(ax=ax, color='blue', legend='100DMA')
        if show200dma:
                if '1D_200-sma' in df.columns:
                        df[['1D_200-sma']].plot(ax=ax, color='green', legend='200DMA')
        #
        # 21-Low/21-High are needed by the following strategies.
        # TODO: Plot x-day low/high.
        #
        if (cfg.strategy_selection == "StrategySwing20DL20DH" or
            cfg.strategy_selection == "StrategySwingPlaceGttAt25DlAndExitOn5pcAvgProfit"):
                if '21-low' in df.columns:
                        df[['21-low']].plot(ax=ax, color='red', legend='21-Low')
                if '21-high' in df.columns:
                        df[['21-high']].plot(ax=ax, color='green', legend='21-High')
        if (cfg.strategy_selection == "Strategy2RSI"):
                if '200-sma' in df.columns:
                        df[['200-sma']].plot(ax=ax, color='black', legend='200-DMA')
                dma = cfg.strategy["sell_above_dma"]
                if ('%d-sma' % dma) in df.columns:
                        df[['%d-sma' % dma]].plot(ax=ax, color='blue', legend='%d-DMA'%dma)

        # StrategySwingBLSH needs X-month low.
        if cfg.strategy_selection == "StrategySwingBLSH":
                x = cfg.strategy["x_months_low"]
                assert(x >= 0.1 and x <= 12)
                #
                # How many trading days in x-months?
                # These should match get_XML_price() in Engine.
                #
                if x >= 1:
                        colname = ("%d-low" % m2d(x))
                        df[[colname]].plot(ax=ax, color='black',
                                        legend=('%d-Month Low' % x))
                else:
                        colname = ("%d-low" % m2d(x))
                        df[[colname]].plot(ax=ax, color='black',
                                        legend=('%d-Day Low' % m2d(x)))

                if ("y_months_high" in cfg.strategy and
                                cfg.strategy["y_months_high"] != 0):
                        y = cfg.strategy["y_months_high"]
                        assert(y >= 0.1 and y <= 12)
                        #
                        # How many trading days in y-months?
                        # These should match get_XMH_price() in Engine.
                        #
                        if y >= 1:
                                colname = ("%d-high" % m2d(y))
                                df[[colname]].plot(ax=ax, color='green',
                                                legend=('%d-Month High' % m2d(y)))
                        else:
                                colname = ("%d-low" % m2d(y))
                                df[[colname]].plot(ax=ax, color='green',
                                                legend=('%d-Day High' % m2d(y)))

        # StrategySwingBLSH3 needs X-day low.
        if cfg.strategy_selection == "StrategySwingBLSH3":
                x = cfg.strategy["x_day_low"]
                assert(x >= 2 and x <= 31)
                #
                # How many trading days in x-months?
                # These should match get_XML_price() in Engine.
                #
                colname = ("%d-low" % x)
                df[[colname]].plot(ax=ax, color='black',
                                legend=('%d-Day Low' % x))
                colname = ("%d-high" % x)
                df[[colname]].plot(ax=ax, color='red',
                                legend=('%d-Day High' % x))

        # StrategyIntraday1 needs 5EMA.
        if (cfg.strategy_selection == "StrategyIntraday1"):
                if '5-ema' in df.columns:
                        df[['5-ema']].plot(ax=ax, color='black', legend='5-EMA')
                if '5-low' in df.columns:
                        df[['5-low']].plot(ax=ax, color='red', legend='5-LOW')


        #
        # Plot additional analytics columns if needed.
        #
        if cfg.analytics_csvfile is not None:
                #
                # Don't show generated orders if toggle is off.
                # This helps to see placed orders clearly, else they get
                # overlapped with generated orders when trigger price is not
                # set.
                #
                if showgenorders:
                        if 'buy_g' in df.columns:
                                df[['buy_g']].plot(ax=ax, color='green', style='o',
                                                   legend='Buy (generate)')
                        if 'sell_g' in df.columns:
                                df[['sell_g']].plot(ax=ax, color='red', style='o',
                                                    legend='Sell (generate)')
                if 'buy_m' in df.columns:
                        df[['buy_m']].plot(ax=ax, color='green', style='+',
                                           legend='Buy (modify)')
                if 'sell_m' in df.columns:
                        df[['sell_m']].plot(ax=ax, color='red', style='+',
                                           legend='Sell (modify)')
                if 'buy_p' in df.columns:
                        df[['buy_p']].plot(ax=ax, color='green', style='^',
                                           legend='Buy (place)')
                if 'sell_p' in df.columns:
                        df[['sell_p']].plot(ax=ax, color='red', style='v',
                                           legend='Sell (place)')

                #
                # Hex color codes copied from
                # https://www.color-hex.com/
                #
                if showskippedorders:
                        if 'buy_s_if' in df.columns:
                                df[['buy_s_if']].plot(ax=ax, color='#0e5d6e', style='s',
                                                      legend='Buy skip (if)')
                        if 'buy_s_ro' in df.columns:
                                df[['buy_s_ro']].plot(ax=ax, color='#b5e4a2', style='s',
                                                      legend='Buy skip (ro)')
                        if 'buy_s_fo' in df.columns:
                                df[['buy_s_fo']].plot(ax=ax, color='#39a592', style='s',
                                                      legend='Buy skip (fo)')
                        if 'buy_s_cd' in df.columns:
                                df[['buy_s_cd']].plot(ax=ax, color='#23ac63', style='s',
                                                      legend='Buy skip (cd)')

                        if 'sell_s_if' in df.columns:
                                df[['sell_s_if']].plot(ax=ax, color='#d1111b', style='s',
                                                       legend='Sell skip (if)')
                        if 'sell_s_ro' in df.columns:
                                df[['sell_s_ro']].plot(ax=ax, color='#facfac', style='s',
                                                       legend='Sell skip (ro)')
                        if 'sell_s_fo' in df.columns:
                                df[['sell_s_fo']].plot(ax=ax, color='#e5a25e', style='s',
                                                       legend='Sell skip (fo)')
                        if 'sell_s_cd' in df.columns:
                                df[['sell_s_cd']].plot(ax=ax, color='#e68677', style='s',
                                                       legend='Sell skip (cd)')

                # exit columns are only created for intraday strategies.
                if 'exit_p' in df.columns:
                        df[['exit_p']].plot(ax=ax, color='green', style='x',
                                            legend='Exit Profit')
                if 'exit_l' in df.columns:
                        df[['exit_l']].plot(ax=ax, color='red', style='x',
                                            legend='Exit Loss')
                # intraday entry price.
                if showenteredorders:
                        if 'enter' in df.columns:
                                df[['enter']].plot(ax=ax, color='black', style='+',
                                                    legend='Enter')


def plot_volume(ax):
        ''' Plot volume on a separate axis.
        '''
        df[['open','close','volume']].plot(ax=ax, kind='volume')
        #df[['5-vema']].plot(ax=ax, color='#c0c030', legend='5-VEMA')
        #
        # Plotting daily VSMA on intraday charts.
        #
        if '1D_3-vsma' in df.columns:
                df[['1D_3-vsma']].plot(ax=ax, color='#c0c030', legend='3-VSMA')

def plot_pvalue(ax):
        ''' Plot portfolio value.
        '''
        assert(cfg.analytics_csvfile is not None)
        df[['pvalue']].plot(ax=ax, color='#c0c030', legend='Portfolio Value')

def plot_funds(ax):
        ''' Plot available funds and investible capital.
        '''
        assert(cfg.analytics_csvfile is not None)
        #
        # Use logarithmic scale for better visibility since funds change drastically.
        #
        fplt.set_y_scale(ax=ax, yscale='log')
        df[['funds']].plot(ax=ax, color='blue', legend='Funds [log]')
        df[['investible']].plot(ax=ax, color='green', legend='Investible [log]')

        #
        # TODO: Open it up and add a checkbox to enable/disable it, since we
        #       don't have much real estate left.
        #
        #fplt.set_y_scale(ax=ax, yscale='linear')
        #df[['dtrend']].plot(ax=ax, color='green', legend='Daily trend')

def plot_pl(ax, pltype):
        ''' Plot profit/loss scatter map.
            Red/Green show profitable/lossy exits, with lighter colors used for
            auto-squareoff (ASO) exits.
        '''
        assert(cfg.analytics_csvfile is not None)

        if pltype == 'P/L(Regular)' or pltype == 'P/L(Both)' or pltype == 'P/L':
                ax.set_visible(xgrid=True, ygrid=True)
                #
                # XXX P/L scatter plot cannot be logarithmic since log plot does
                #     not show -ve values.
                #
                #fplt.set_y_scale(ax=ax, yscale='log')
                fplt.set_y_scale(ax=ax, yscale='linear')

                if 'pl_p' in df.columns:
                        df[['pl_p']].plot(ax=ax, color='green',
                                          kind='scatter', legend='Profit')
                if 'pl_l' in df.columns:
                        df[['pl_l']].plot(ax=ax, color='red',
                                          kind='scatter', legend='Loss')

        #
        # ASO scatter dots use ligher shades of red/green colors.
        # These are only present for intraday strategies.
        #
        if pltype == 'P/L(ASO)' or pltype == 'P/L(Both)':
                ax.set_visible(xgrid=True, ygrid=True)
                fplt.set_y_scale(ax=ax, yscale='linear')

                if 'pl_p_aso' in df.columns:
                        df[['pl_p_aso']].plot(ax=ax, color='#7f5',
                                              kind='scatter', legend='Profit (ASO)')
                if 'pl_l_aso' in df.columns:
                        df[['pl_l_aso']].plot(ax=ax, color='#f75',
                                              kind='scatter', legend='Loss (ASO)')

def plot_quantity(ax, pltype):
        ''' Plot buy/sell quantity scatter map.
        '''
        assert(cfg.analytics_csvfile is not None)

        if pltype == 'Quantity':
                ax.set_visible(xgrid=True, ygrid=True)
                fplt.set_y_scale(ax=ax, yscale='linear')

                if 'buy_q' in df.columns:
                        df[['buy_q']].plot(ax=ax, color='green',
                                          kind='scatter', legend='Buy quantity')
                if 'sell_q' in df.columns:
                        df[['sell_q']].plot(ax=ax, color='red',
                                          kind='scatter', legend='Sell quantity')

def plot_avgp(ax, pltype):
        ''' Plot average buy price scatter plot.
        '''
        assert(cfg.analytics_csvfile is not None)

        if pltype == 'Avg-Buy-Price':
                ax.set_visible(xgrid=True, ygrid=True)
                #
                # TODO [BUG] yscale='linear' doesn't work after refresh.
                #
                fplt.set_y_scale(ax=ax, yscale='log')

                if 'buy_avgp' in df.columns:
                        df[['buy_avgp']].plot(ax=ax, color='green',
                                          kind='scatter', legend='Average Buy Price [log]')

def plot_tq(ax, pltype):
        ''' Plot total buy quantity scatter plot.
        '''
        assert(cfg.analytics_csvfile is not None)

        if pltype == 'Total-Quantity':
                ax.set_visible(xgrid=True, ygrid=True)
                fplt.set_y_scale(ax=ax, yscale='linear')

                if 'buy_tq' in df.columns:
                        df[['buy_tq']].plot(ax=ax, color='green',
                                          kind='scatter', legend='Total Quantity')

def plot_bullishness(ax, pltype):
        ''' Plot bullishness index for each candle.
        '''
        assert(cfg.analytics_csvfile is not None)

        if pltype == 'Bullishness':
                ax.set_visible(xgrid=False, ygrid=False)

                if 'bullishness' in df.columns:
                        #
                        # Setting y range disables auto-scale selection for
                        # y axis for any future plots in that pane, and there
                        # doesn't seem to be a way to again enable auto-zoom,
                        # so don't set y scale, it will be correctly set by
                        # finplot.
                        #
                        #fplt.set_y_range(0, 100, ax=ax)
                        fplt.set_y_scale(ax=ax, yscale='linear')
                        df[['bullishness']].plot(ax=ax, color='#c0c030', legend='bullishness')

def plot_rsi(ax, pltype):
        assert(cfg.analytics_csvfile is not None)

        if rsi_period is None:
                return

        buy_below_rsi_percent = cfg.strategy["buy_below_rsi_percent"]

        if pltype == ('%d-RSI' % rsi_period):
                fplt.set_y_range(0, 100, ax=ax)
                fplt.set_y_scale(ax=ax, yscale='linear')
                fplt.add_band(buy_below_rsi_percent, 100-buy_below_rsi_percent, ax=ax)

                df[['%d-rsi' % rsi_period]].plot(ax=ax, color='#c0c030', legend='%d-RSI'%rsi_period)

def redraw_ax3(savewindata=True):
        ''' Resets and recalculates everything, and plots for the first time.
        '''
        print("redraw_ax3() called");
        assert(cfg.analytics_csvfile is not None)

        # save window zoom position before resetting
        if savewindata:
                fplt._savewindata(fplt.windows[0])

        #
        # Get the p/l type to show.
        #
        global combobox_index
        #combobox_index = cpanel.exittype.currentIndex()
        #exittype = cpanel.exittype.currentText()

        combobox_index = 0;
        exittype = 'P/L'

        # Remove any previous plots
        ax3.reset()

        # Plot fresh.
        plot_pl(ax3, exittype)
        plot_quantity(ax3, exittype)
        plot_rsi(ax3, exittype)
        plot_tq(ax3, exittype)
        plot_avgp(ax3, exittype)
        plot_bullishness(ax3, exittype)

        # Restores saved zoom position, if in range.
        if savewindata:
                fplt.refresh()

def clear_layout(layout):
        ''' Clear all widgets in the layout.
        '''
        while layout.count():
                child = layout.takeAt(0)
                if child.widget():
                        child.widget().deleteLater()

def create_cpanel(win):
        ''' Create a control panel to host the P/L/Quantity drop-down menu.
        '''
        global cpanel
        global layout
        global combobox_type
        global combobox_index

        if cpanel is None:
                cpanel = QWidget(win)
                cpanel.move(150, -5)
                layout = QGridLayout(cpanel)
                layout.setColumnMinimumWidth(1, 40)
        else:
                assert(layout is not None)
                clear_layout(layout)
                #layout.removeWidget(cpanel.exittype)
                #layout.removeWidget(cpanel.button)
                # TODO: [BUG] This causes a crash.
                #layout.removeWidget(cpanel.nolegend)

        return
        row_num = 0

        # Create a checkbox for clearing eveything.
        cpanel.clearall = QCheckBox(cpanel)
        cpanel.clearall.setText('Clear all')
        if clear_all:
                cpanel.clearall.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.clearall.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.clearall.toggled.connect(_redraw_clearall)
        layout.addWidget(cpanel.clearall, row_num, 1)
        row_num += 1

        if clear_all:
                return

        cpanel.button = QPushButton('Refresh', cpanel)
        cpanel.button.setToolTip('Press this to redraw the plot with updated values')
        #cpanel.button.move(100,70)
        cpanel.button.clicked.connect(redraw)
        layout.addWidget(cpanel.button, 0, 0)

        # Create a fresh QComboBox.
        cpanel.exittype = QComboBox(cpanel)

        if is_intraday():
                stropt='P/L(Regular) P/L(ASO) P/L(Both) Quantity'
                if 'bullishness' in df.columns:
                        stropt += ' Bullishness'
                [cpanel.exittype.addItem(i) for i in stropt.split()]
                # Remember and reset combobox_index if combobox_type is same.
                if combobox_type == 1:
                        cpanel.exittype.setCurrentIndex(combobox_index)
                else:
                        cpanel.exittype.setCurrentIndex(2)
                        combobox_index = 2
                combobox_type = 1
        else:
                stropt='P/L Quantity'
                if rsi_period is not None:
                        stropt += ' %d-RSI' % rsi_period
                if 'buy_tq' in df.columns:
                        stropt += ' Total-Quantity'
                if 'buy_avgp' in df.columns:
                        stropt += ' Avg-Buy-Price'
                [cpanel.exittype.addItem(i) for i in stropt.split()]

                if rsi_period is None:
                        #
                        # If combobox_index refers to the same combobox_type
                        # as current, use combobox_index, else reset it.
                        #
                        if combobox_type == 2:
                                cpanel.exittype.setCurrentIndex(combobox_index)
                        else:
                                cpanel.exittype.setCurrentIndex(0)
                                combobox_index = 0
                        combobox_type = 2
                else:
                        if combobox_type == 3:
                                cpanel.exittype.setCurrentIndex(combobox_index)
                        else:
                                cpanel.exittype.setCurrentIndex(2)
                                combobox_index = 2
                        combobox_type = 3

        # Redraw ax3 when combobox selection changes.
        cpanel.exittype.currentTextChanged.connect(redraw_ax3)
        layout.addWidget(cpanel.exittype, 1, 0)

        # Create a checkbox for showing/hiding legend.
        cpanel.nolegend = QCheckBox(cpanel)
        cpanel.nolegend.setText('Show legend')
        if hide_legend:
                cpanel.nolegend.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        else:
                cpanel.nolegend.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        cpanel.nolegend.toggled.connect(_redraw)
        layout.addWidget(cpanel.nolegend, row_num, 1)
        row_num += 1

        #
        # Create a checkbox for showing/hiding generated orders.
        # We need to toggle generated orders as they usually mask the placed
        # order for orders with no trigger price and by hiding generated
        # orders we can see the placed orders clearly.
        #
        cpanel.showgenorders = QCheckBox(cpanel)
        cpanel.showgenorders.setText('Show generated orders')
        if showgenorders:
                cpanel.showgenorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.showgenorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.showgenorders.toggled.connect(_redraw_genorders)
        layout.addWidget(cpanel.showgenorders, row_num, 1)
        row_num += 1

        #
        # Create a checkbox for showing/hiding entered orders.
        # We need to toggle entered orders to avoid clutter as we usually
        # don't need to know when the order was entered but it's useful to see
        # sometime to make sure our Exchange emulator correctly matched the
        # order on the right candle and not on some candle before the order
        # was even generated or on which the limit price didn't occur.
        # Also it helps to know the entry price considered.
        #
        cpanel.showenteredorders = QCheckBox(cpanel)
        cpanel.showenteredorders.setText('Show entered orders')
        if showenteredorders:
                cpanel.showenteredorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.showenteredorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.showenteredorders.toggled.connect(_redraw_enteredorders)
        layout.addWidget(cpanel.showenteredorders, row_num, 1)
        row_num += 1

        #
        # Create a checkbox for showing/hiding skipped orders.
        # We need to toggle skipped orders as there are usually too many of
        # them especially with the new confidence based strategy backtester,
        # where we allow many orders to be generated and then filter them
        # based on their confidence value. Many of the skipped orders are the
        # one skipped due to low confidence which show as skipped due to "cd"
        # (ConfigDisallow).
        #
        cpanel.showskippedorders = QCheckBox(cpanel)
        cpanel.showskippedorders.setText('Show skipped orders')
        if showskippedorders:
                cpanel.showskippedorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.showskippedorders.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.showskippedorders.toggled.connect(_redraw_skippedorders)
        layout.addWidget(cpanel.showskippedorders, row_num, 1)
        row_num += 1

        #
        # 200DMA can prevent autoscaling from properly scaling the y-axis
        # causing minute hard-to-see candles, since 200DMA might be very less
        # compared to the zoomed in price range, thus preventing y-axis to
        # properly scale.
        # Provide checkbox to view 200DMA.
        #
        cpanel.show200dma = QCheckBox(cpanel)
        cpanel.show200dma.setText('Show 200DMA')
        if show200dma:
                cpanel.show200dma.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.show200dma.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.show200dma.toggled.connect(_redraw_200dma)
        layout.addWidget(cpanel.show200dma, row_num, 1)
        row_num += 1

        #
        # Checkbox for selecting full timerange.
        # By default only [starttick, endtick] range is shown, as that's where
        # much of the action happens, but sometimes it's useful to see
        # historical price variation too.
        #
        cpanel.show_full_timerange = QCheckBox(cpanel)
        cpanel.show_full_timerange.setText('Show full timerange')
        if show_full_timerange:
                cpanel.show_full_timerange.setCheckState(pg.Qt.QtCore.Qt.CheckState.Checked)
        else:
                cpanel.show_full_timerange.setCheckState(pg.Qt.QtCore.Qt.CheckState.Unchecked)
        cpanel.show_full_timerange.toggled.connect(_redraw_full_timerange)
        layout.addWidget(cpanel.show_full_timerange, row_num, 1)


def _redraw_genorders(checked):
        print("_redraw_genorders(checked=%s)" % checked)
        global showgenorders
        showgenorders = checked

        _redraw(not hide_legend)

def _redraw_enteredorders(checked):
        print("_redraw_enteredorders(checked=%s)" % checked)
        global showenteredorders
        showenteredorders = checked

        _redraw(not hide_legend)

def _redraw_skippedorders(checked):
        print("_redraw_skippedorders(checked=%s)" % checked)
        global showskippedorders
        showskippedorders = checked

        _redraw(not hide_legend)

def _redraw_200dma(checked):
        print("_redraw_200dma(checked=%s)" % checked)
        global show200dma
        show200dma = checked

        _redraw(not hide_legend)

def _redraw_full_timerange(checked):
        print("_redraw_full_timerange(checked=%s)" % checked)
        global show_full_timerange
        show_full_timerange = checked

        _redraw(not hide_legend)

def _redraw_clearall(checked):
        print("_redraw_clearall(checked=%s)" % checked)
        global clear_all
        clear_all = checked

        global saved_hide_legend
        saved_hide_legend = hide_legend

        _redraw((not saved_hide_legend) if not checked else False)

#
# This is the python utility program for plotting.
#
def _redraw(show_legend):
        print("_redraw(show_legend=%s)" % show_legend)

        global hide_legend
        hide_legend = not show_legend

        # Reload config if user has changed it.
        importlib.reload(cfg)

        # Window title depends on config, set it now.
        axc.vb.win.setWindowTitle(get_titlebar())

        global df
        df = get_df()

        global rsi_period
        if (cfg.strategy_selection == "Strategy2RSI"):
                rsi_period = cfg.strategy["rsi_period"]
        else:
                rsi_period = None

        # Plot fresh.
        # save window zoom position before resetting
        fplt._savewindata(fplt.windows[0])

        # Remove any previous plots
        axc.reset()
        axv.reset()

        # Redraw.
        plot_candles(axc)
        plot_volume(axv)

        #
        # Create the drop-down menu and refresh button if plotting analytics data,
        # and if not already created.
        # Plot portfolio value if analytics data is present.
        #
        if cfg.analytics_csvfile is not None:
                create_cpanel(axc.vb.win)
                # Don't save/restore windata as we have already done in this
                # function.
                redraw_ax3(savewindata=False)

                # Remove any previous plots
                ax1.reset()
                ax2.reset()

                plot_pvalue(ax1)
                plot_funds(ax2)

        if not show_legend:
                for ax in [axc, axv, ax1, ax2, ax3]:
                        if ax is not None and ax.legend:
                                ax.legend.opts['offset'] = None
                                ax.legend.setParentItem(None)
                                ax.legend = None

        # Restores saved zoom position, if in range.
        fplt.refresh()

def redraw():
        _redraw(not hide_legend)

def main():
        # Default legend colors are not easily readable.
        fplt.legend_text_color = 'black'

        # Avoid warning from Qt.
        os.environ["XDG_RUNTIME_DIR"] = "/tmp/runtime-root"

        global axc, axv, ax1, ax2, ax3

        #
        # Create following axes:
        # ax  -> Price candlestick.
        # axv -> Volume.
        # ax1 -> Portfolio Value
        # ax2 -> Funds
        # ax3 -> P/L
        #
        if cfg.analytics_csvfile is not None:
                axc,axv,ax1,ax2,ax3 = fplt.create_plot(get_titlebar(), rows=5)
        else:
                #
                # Not plotting analytics, just the candle and volume data for
                # the given stock.
                #
                axc,axv = fplt.create_plot(cfg.symbol, rows=2)

        redraw()

        # Restore view (X-position and zoom) when we run this example again.
        fplt.autoviewrestore()
        fplt.show()

if __name__ == '__main__':
        main()
