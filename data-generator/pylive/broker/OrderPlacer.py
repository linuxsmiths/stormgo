import os, sys, csv, setproctitle, re, time, json, signal, shutil
import pandas as pd
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'common'))

import multiprocessing
import inotify.adapters
import config as cfg
from helpers import *

#
# TODO:
# - handle partially filled orders.
#

# It must have same value as Order.h
MIN_ORDERID = 1000000
profileFetched = False
refresh_thread = None
aso_thread = None
shall_refresh_orders_now = False

#
# epoch (local timezone) when all orders in orderbook/orderbook are dumped as
# orderbook/{broker_orderid} and orders in gtt/gttlist are dumped as gtt/{ruleid}.
# We dump all orders and GTT once, when either engine restarts or pylive restarts
# to make sure engine always have correct/uptodate data from the broker.
#
orderbook_dumpall_epoch = 0

#
# Special orderid to instruct OrderPlacer to squareoff all intraday orders
# which are not completed yet.
#
squareoff_orderid = 1000

if cfg.broker['selection'] == "angelone":
    import AngelOne as broker
else:
    # Till we support other brokers.
    ASSERT(False)

generated_dir = os.path.join(cfg.srcdir, "pylive/orders/generated")
placing_dir = os.path.join(cfg.srcdir, "pylive/orders/placing")
placed_dir = os.path.join(cfg.srcdir, "pylive/orders/placed")
failed_dir = os.path.join(cfg.srcdir, "pylive/orders/failed")
squaredoff_dir = os.path.join(cfg.srcdir, "pylive/orders/squaredoff")
cancelled_dir = os.path.join(cfg.srcdir, "pylive/orders/cancelled")
executed_dir = os.path.join(cfg.srcdir, "pylive/orders/executed")
partially_executed_dir = os.path.join(cfg.srcdir, "pylive/orders/executed/partial")
orderbook_dir = os.path.join(cfg.srcdir, "pylive/orders/orderbook")
external_orders_dir = os.path.join(cfg.srcdir, "pylive/orders/orderbook/external-orders")
gtt_dir = os.path.join(cfg.srcdir, "pylive/orders/gtt")
account_dir = os.path.join(cfg.srcdir, "pylive/orders/account")
holdings_dir = os.path.join(cfg.srcdir, "pylive/orders/holdings")
positions_dir = os.path.join(cfg.srcdir, "pylive/orders/positions")
# LTP is updated here for each stock, by CandleGenerator.
ltp_dir = os.path.join(cfg.srcdir, "pylive/orders/ltp")

inotify_adapter = None
runner_stopped_gracefully = False

def ASSERT_IS_VALID_ENGINE_ORDER(order):
    ''' Check if the given order json is a valid order generated by the engine.
    '''
    # Basic sanity.
    ASSERT(pd.Timestamp(order['timestamp'], unit='s') > pd.Timestamp("01/01/2020"))
    ASSERT(pd.Timestamp(order['timestamp'], unit='s') <= pd.Timestamp.now())

    # action is must and can be one of the three.
    ASSERT((order['action'] == "create") or
           (order['action'] == "cancel") or
           (order['action'] == "modify"))

    # engine orderid is must and is an integer.
    ASSERT(isinstance(order['orderid'], int))
    ASSERT(re.compile('^[0-9]+$').match(str(order['orderid'])) is not None)

    #
    # A valid tradingsymbol is a must.
    # We don't need it for order cancellation but GTT cancellation needs it,
    # so let's mandate it.
    #
    ASSERT(broker.is_valid_symbol(order['tradingsymbol']))

    if order['action'] == "cancel":
        ASSERT(order['transactiontype'] == "")
        ASSERT(order['ordertype'] == "")
        ASSERT(order['quantity'] == 0)
    else:
        ASSERT((order['transactiontype'] == "BUY") or (order['transactiontype'] == "SELL"))
        ASSERT((order['ordertype'] == "LIMIT") or (order['ordertype'] == "MARKET"))
        ASSERT(order['quantity'] > 0)

    ASSERT((order['producttype'] == "BO") or
           (order['producttype'] == "DELIVERY") or
           (order['producttype'] == "GTT"))

    # We don't support SL/SL-M orders.
    if order['producttype'] == "DELIVERY":
        # Delivery orders are market orders and cannot be cancelled or modified.
        ASSERT(order['action'] == "create")
        ASSERT(order['ordertype'] == "MARKET")
        ASSERT(order['price'] > 0)
        ASSERT(order['triggerprice'] == 0)
        ASSERT(order['squareoff'] == 0)
        ASSERT(order['stoploss'] == 0)

    if order['producttype'] == "BO":
        #
        # Bracket orders cannot be cancelled or modified (they can be
        # squaredoff though).
        #
        ASSERT(order['action'] == "create")
        ASSERT(order['price'] > 0)
        ASSERT(order['triggerprice'] == 0)
        ASSERT(order['squareoff'] > 0)
        ASSERT(order['stoploss'] > 0)

    if order['producttype'] == "GTT":
        #
        # GTT orders can be created, cancelled or modified, and when created
        # or modified they need a triggerprice but not for cancel.
        #
        ASSERT((order['triggerprice'] == 0) == (order['action'] == "cancel"))
        ASSERT((order['price'] == 0) == (order['action'] == "cancel"))
        ASSERT(order['squareoff'] == 0)
        ASSERT(order['stoploss'] == 0)

    ASSERT(isinstance(order['price'], float))
    ASSERT(isinstance(order['triggerprice'], float))
    ASSERT(isinstance(order['squareoff'], float))
    ASSERT(isinstance(order['stoploss'], float))

    # Engine orders placed with the broker have few more attributes added.
    if 'broker_action' in order:
        ASSERT((order['broker_action'] == "placed") or
               (order['broker_action'] == "cancelled") or
               (order['broker_action'] == "modified"))
        if order['broker_action'] == "placed":
            ASSERT(order['action'] == "create")
        if order['broker_action'] == "cancelled":
            ASSERT(order['action'] == "cancel")
        if order['broker_action'] == "modified":
            ASSERT(order['action'] == "modify")
        ASSERT(pd.Timestamp(order['broker_timestamp'], unit='s') <= pd.Timestamp.now())
        ASSERT(pd.Timestamp(order['broker_timestamp'], unit='s') > pd.Timestamp("01/01/2020"))
        # broker_orderid should be a string.
        ASSERT(isinstance(order['broker_orderid'], str))
        ASSERT(order['broker_orderid'] != "")
        # GTT orders have empty broker_uniqueorderid.
        ASSERT((order['broker_uniqueorderid'] != "") == (order['producttype'] != "GTT"))

def get_ltp(symbol):
    ''' Returns LTP details for symbol, in the form:
        {
            "subscription_mode": 2,
            "exchange_type": 1,
            "token": "11630",
            "sequence_number": 6950681,
            "exchange_timestamp": 1714629059000,
            "last_traded_price": 36790,
            "subscription_mode_val": "QUOTE",
            "last_traded_quantity": 3,
            "average_traded_price": 36653,
            "volume_trade_for_the_day": 9745238,
            "total_buy_quantity": 926745.0,
            "total_sell_quantity": 1683466.0,
            "open_price_of_the_day": 36320,
            "high_price_of_the_day": 36930,
            "low_price_of_the_day": 36320,
            "closed_price": 36320
        }

        Note: This data was added to pylive/orders/<symbol> by CandleGenerator.
    '''
    ltp_file = os.path.join(ltp_dir, symbol)
    try:
        with open(ltp_file) as f:
            ltp = json.load(f)
    except Exception as e:
        PYPError("Failed to open LTP file %s: %s" % (ltp_file, e))
        #
        # Since we create LTP file for every symbol, this shouldn't fail, but
        # it's possible that we get some gtt/order from broker before we could
        # get any tick for that stock, so we may not have the LTP. Since this
        # is a temporary state, we ignore it.
        #
        #ASSERT(False)
        return None
    return ltp

#
# engine_orderbook json looks like this, basically it's an array of orders as
# generated by engine with the corresponding broker_orderid attribute added
# after the order is successfully placed with the broker.
#
# {
#     "orders": [
#         {
#             "timestamp": 1703158811,
#             "orderid": 5777664046329948764,
#             "tradingsymbol": "WIPRO",
#             "transactiontype": "BUY",
#             "ordertype": "LIMIT",
#             "quantity": 1,
#             "producttype": "BO",
#             "price": 454.75,
#             "triggerprice": 0.0,
#             "squareoff": 1.0,
#             "stoploss": 0.5,
#             "trailingStopLoss": 0,
#             "broker_action": "placed",
#             "broker_timestamp": 1704805721.966316,
#             "broker_orderid": "240109000947550",
#             "broker_uniqueorderid": "f488b0e5-9c36-4592-b0ac-8d89cd727cf8"
#         },
#         {
#             "timestamp": 1703158811,
#             "orderid": 5777664046329948764,
#             "tradingsymbol": "WIPRO",
#             "transactiontype": "BUY",
#             "ordertype": "LIMIT",
#             "quantity": 1,
#             "producttype": "BO",
#             "price": 455.1,
#             "triggerprice": 0.0,
#             "squareoff": 1.0,
#             "stoploss": 0.5,
#             "trailingStopLoss": 0,
#             "broker_action": "placed",
#             "broker_timestamp": 1704806034.472025,
#             "broker_orderid": "240109000959461",
#             "broker_uniqueorderid": "959b84d1-6e4d-49f3-80ae-d27e7dc44133"
#         }
#     ],
#     "timestamp": 1704806034.475041
# }
#
# Also see:
#       RealBroker::engine_to_broker_orderid() and
#       RealBroker::broker_to_engine_orderid().
#
def engine_orderid_to_broker_orderid(engine_orderid):
    ''' Given an engine orderid return the corresponding broker orderid.
        Note that every order generated by the engine is placed with the real
        broker which then creates its own order id.
    '''
    # engine_orderid must be an integer.
    ASSERT(isinstance(engine_orderid, int))
    ASSERT(re.compile('^[0-9]+$').match(engine_orderid) is not None)

    engine_orderbook_file = os.path.join(placed_dir, "engine_orderbook")

    if not os.path.exists(engine_orderbook_file):
        PYPWarn("%s not present, while searching for engine_orderid %s" %
                (engine_orderbook_file, engine_orderid))
        return None

    try:
        with open(engine_orderbook_file) as f:
            engine_orderbook = json.load(f)
    except Exception as e:
        PYPError("Failed to open %s, while searching for engine_orderid %s: %s" %
                (engine_orderbook_file, engine_orderid, e))
        return None

    # engine_orderbook MUST have a valid timestamp, in the past.
    ASSERT(pd.Timestamp(engine_orderbook['timestamp'], unit='s') <= pd.Timestamp.now())

    orders = engine_orderbook['orders']
    if orders is not None:
        for order in orders:
            ASSERT_IS_VALID_ENGINE_ORDER(order)
            if engine_orderid == order['orderid']:
                PYPInfo("[E2B orderid] %s -> %s (broker_action=%s)" %
                        (engine_orderid, order['broker_orderid'],
                         order['broker_action']))
                return order['broker_orderid']

    PYPError("Did not find engine_orderid %s in %s" %
            (engine_orderid, engine_orderbook_file))
    return None

def broker_orderid_to_engine_orderid(broker_orderid):
    ''' Given a broker orderid return the corresponding engine orderid.
        Note that every order generated by the engine is placed with the real broker
        which then creates its own order id.
    '''
    ASSERT(isinstance(broker_orderid, str))

    engine_orderbook_file = os.path.join(placed_dir, "engine_orderbook")

    if not os.path.exists(engine_orderbook_file):
        PYPWarn("%s not present, while searching for broker_orderid %s" %
                (engine_orderbook_file, broker_orderid))
        return None

    try:
        with open(engine_orderbook_file) as f:
            engine_orderbook = json.load(f)
    except Exception as e:
        PYPError("Failed to open %s, while searching for broker_orderid %s: %s" %
                (engine_orderbook_file, broker_orderid, e))
        return None

    # engine_orderbook MUST have a valid timestamp, in the past.
    ASSERT(pd.Timestamp(engine_orderbook['timestamp'], unit='s') <= pd.Timestamp.now())

    orders = engine_orderbook['orders']
    if orders is not None:
        for order in orders:
            #
            # XXX
            # This assert is commented because orders added to engine
            # orderbook don't meet all the invariants of an order generated by
            # engine, f.e., for cancelled orders we may have the triggerprice
            # if the original order had it, this is because we mark the
            # existing orders as cancelled in the engine orderbook. Contrast
            # this with cancel orders generated by the engine which won't have
            # triggerprice or price.
            #
            #ASSERT_IS_VALID_ENGINE_ORDER(order)
            if broker_orderid == order['broker_orderid']:
                PYPInfo("[B2E orderid] %s -> %s (broker_action=%s)" %
                        (broker_orderid, str(order['orderid']),
                         order['broker_action']))
                return str(order['orderid'])

    PYPError("Did not find broker_orderid %s in %s" %
            (broker_orderid, engine_orderbook_file))
    return None

def create_empty_engine_orderbook():
    ''' orders/placed/engine_orderbook contains all orders placed by the engine.
        OrderPlacer keeps it updated and engine places an inotify watch on it when
        it starts. We should create an empty engine_orderbook file so that engine
        can place an inotify watch on it. Later when engine places an order we update
        engine_orderbook file and engine will get notified.
    '''
    engine_orderbook_file = os.path.join(placed_dir, "engine_orderbook")
    if os.path.exists(engine_orderbook_file):
        PYPPass("%s already present, not creating!" % (engine_orderbook_file));
        return

    #
    # Create engine_orderbook json file with empty orders array.
    #
    engine_orderbook = {"orders": []}
    engine_orderbook["timestamp"] = pd.Timestamp.now().timestamp()

    try:
        with open(engine_orderbook_file, 'w') as f:
            json.dump(engine_orderbook, f, indent=4)
            PYPPass("Created empty %s with no orders:\n%s" %
                    (engine_orderbook_file, json.dumps(engine_orderbook, indent=4)))
    except Exception as e:
        PYPError("Failed to create %s:\n%s" %
                 (engine_orderbook_file, json.dumps(engine_orderbook, indent=4)))
        #
        # Treat this as fatal as engine will fail to start w/o this file.
        #
        ASSERT(False)
        return

def update_engine_orderbook(order):
    ''' Update engine orderbook to reflect this new order.
        If the new order is a create order, it will add a fresh order to the engine
        orderbook.
        If the new order is a cancel/modify order, it will update the existing order
        in engine orderbook to reflect the change.
        If the cancel/modify order doesn't exist in the engine orderbook it logs a
        warning and ignores. THIS SHOULD NOT HAPPEN IN PRACTICE AS ENGINE SHOULD NOT
        ASK TO CANCEL/MODIFY NON-EXISTENT ORDERS.

        Note that engine orderbook contains an uptodate reflection of all orders placed
        by the engine with the broker and it is what we use to convert between engine
        and broker order ids, hence *all* orders placed by engine MUST be added to
        engine_orderbook.

        These include GTT orders too.
    '''
    # Only a valid engine order must be passed here.
    ASSERT_IS_VALID_ENGINE_ORDER(order)

    #
    # And the order must have been placed with the broker, so must have the
    # additional attributes.
    #
    ASSERT("broker_orderid" in order)
    ASSERT(isinstance(order['broker_orderid'], str))
    ASSERT(len(order['broker_orderid']) > 0)
    ASSERT("broker_action" in order)
    ASSERT("broker_timestamp" in order)
    ASSERT("broker_uniqueorderid" in order)

    engine_orderbook_file = os.path.join(placed_dir, "engine_orderbook")
    if os.path.exists(engine_orderbook_file):
        try:
            with open(engine_orderbook_file) as f:
                engine_orderbook = json.load(f)
                # We should not have an empty engine orderbook.
                ASSERT(len(engine_orderbook["orders"]) > 0)
        except Exception as e:
            PYPError("Failed to open %s: %s" % (engine_orderbook_file, e))
            return
    else:
        engine_orderbook = {"orders": []}

    #
    # Check engine_orderbook to see if order already exists.
    # We expect the order to be present (only) in case it's a cancel/modify order.
    #
    existing_order = None
    for o in engine_orderbook["orders"]:
        ASSERT(isinstance(o['broker_orderid'], str))
        ASSERT(len(o['broker_orderid']) > 0)
        if o['broker_orderid'] == order['broker_orderid']:
            existing_order = o
            break

    if order['action'] == "create":
        ASSERT(order['broker_action'] == "placed")
        #
        # Newly created order already exists?
        #
        # XXX This can happen when engine order reuses an existing orderid which
        #     is only possible when creating orders by hand. Watch out for this
        #     and always pick a fresh orderid for a new order.
        #     We assert as an error as not adding order to engine orderbook
        #     may cause issues later.
        #
        if existing_order is not None:
            PYPError("[BUG] Order to be added already exists in "
                     "engine_orderbook:\nNEW=%s\nEXISTING=%s" %
                     (json.dumps(order, indent=4), json.dumps(existing_order, indent=4)))
            ASSERT(False)
            return

        # Add the new order.
        engine_orderbook["orders"] += [order]
        engine_orderbook["timestamp"] = pd.Timestamp.now().timestamp()
        PYPPass("Adding newly placed order to engine orderbook, total now %d: %s" %
                (len(engine_orderbook["orders"]), json.dumps(order, indent=4)))
    elif order['action'] == "cancel":
        ASSERT(order['broker_action'] == "cancelled")
        if existing_order is None:
            PYPError("[BUG] Order to be cancelled does not exist in "
                     "engine_orderbook:\n%s" %
                     (json.dumps(order, indent=4)))
            ASSERT(False)
            return

        PYPPass("Marking order as cancelled in engine orderbook, total now %d: %s" %
                (len(engine_orderbook["orders"]), json.dumps(existing_order, indent=4)))
        #
        # Existing order can only have broker_action "placed" or "modified",
        # as we should not cancel an already cancelled order.
        #
        ASSERT((existing_order["broker_action"] == "placed") or
               (existing_order["broker_action"] == "modified"))

        existing_order["action"] = "cancel"
        existing_order["broker_action"] = "cancelled"
        engine_orderbook["timestamp"] = pd.Timestamp.now().timestamp()
    elif order['action'] == "modify":
        ASSERT(order['broker_action'] == "modified")
        if existing_order is None:
            PYPError("[BUG] Order to be modified does not exist in "
                     "engine_orderbook:\n%s" %
                     (json.dumps(order, indent=4)))
            ASSERT(False)
            return

        PYPPass("Marking order as modified in engine orderbook, total now %d: %s" %
                (len(engine_orderbook["orders"]), json.dumps(existing_order, indent=4)))
        #
        # Existing order can only have broker_action "placed" or "modified",
        # as we should not modify an already cancelled order.
        #
        ASSERT((existing_order["broker_action"] == "placed") or
               (existing_order["broker_action"] == "modified"))

        existing_order["action"] = "modify"
        existing_order["broker_action"] = "modified"
        engine_orderbook["timestamp"] = pd.Timestamp.now().timestamp()

    #
    # Now dump the updated engine_orderbook.
    #
    try:
        with open(engine_orderbook_file, 'w') as f:
            json.dump(engine_orderbook, f, indent=4)
            PYPPass("Updated %s is:\n%s" %
                    (engine_orderbook_file, json.dumps(engine_orderbook, indent=4)))
    except Exception as e:
        PYPError("Failed to update %s:\n%s" %
                (engine_orderbook_file, json.dumps(engine_orderbook, indent=4)))
        return

def process_all_generated_orders():
    ''' Helper function to process *all* generated orders.
        This is usually not required as we process orders as they are generated,
        when the corresponding inotify event is generated, but in some cases,
        f.e., after restart, it may be a good idea to go over all generated
        orders.

        Note: This needs to be used with caution as it may not make sense to
              place an old order as it may not be valid anymore.
    '''
    #
    # List all file in generated_dir and filter out the ones that look like
    # order json file. Order json files are named with the orderid which is a
    # 64 bit integer.
    #
    orders = os.listdir(generated_dir)
    PYPLog('Files found in %s: %s' % (generated_dir, orders))

    # Filter probable order jsons.
    regex = re.compile('^[0-9]+$')
    orders = list(filter(regex.search, orders))

    if not orders:
        PYPLog('No generated orders to process')
        return

    for order in orders:
        process_generated_order(order)

def squareoff_all_open_intraday_orders():
    ''' This must be called at 03:05PM to squareoff all open intraday orders to
        avoid auto-squareoff charges from broker (which squares off at 03:10PM).

        It goes over all the orders from the orderbook (returned by the broker API)
        and looks for the ROBO orders which are not closed. We get orders to squareoff
        from the latest broker orderbook and not from our saved orderbook so that
        we can even squareoff orders not created by engine (created externally from
        portal or app).
    '''
    orderbook = broker.get_order_book()
    if orderbook['status'] != True:
        PYPError("[auto-squareoff] [AngelOne BUG] Failed to get order book:\n%s" %
                json.dumps(orderbook, indent=4))
        return

    PYPInfo("[auto-squareoff] Got order book: %s" % json.dumps(orderbook, indent=4))

    #
    # Go over all bracket orders and auto-squareoff the BO orders which are
    # still not completed.
    #
    # Note: Order status may change after we fetch the orderbook, we should
    #       be ready to handle that.
    #
    orders = orderbook['data']
    if orders is None or len(orders) == 0:
        PYPWarn("[auto-squareoff] No orders (%s) returned in broker orderbook!" %
                (len(orders) if orders is not None else "None"))
        return

    for order in orders:
        #
        # We can only squareoff ROBO orders.
        #
        if not broker.is_robo_main_order(order):
            continue

        #
        # TODO: Check for more orderstatus.
        #
        if order['orderstatus'] == 'cancelled':
            PYPWarn("[auto-squareoff] Ignoring cancelled ROBO order:\n%s" %
                    json.dumps(order, indent=4))
            continue

        PYPInfo("[auto-squareoff] Squaring off ROBO order:\n%s" % json.dumps(order, indent=4))

        #
        # If not cancelled, the ROBO order must only be in one of the
        # following states:
        # 1. open       -> The order didn't meet the limit price hence didn't
        #                  enter.
        # 2. complete   -> The order is either partially or fully completed
        #
        ASSERT((order['orderstatus'] == "open") or
               (order['orderstatus'] == "complete"))

        #
        # Both above states indicate that the order was successfully placed
        # with the broker, hence the json file corresponding to the order
        # would be in placed_dir.
        #
        # "Fully completed" orders can be already in executed_dir, move there
        # by refresh_orders()->move_to_correct_orders_dir().
        #

        broker_orderid = order['orderid']

        # Ask broker routine to squareoff the order.
        cancelled, squaredoff = broker.squareoff_robo_order(broker_orderid, orderbook)

        #
        # If the ROBO order was placed outside engine then we won't have an
        # engine_orderid and we don't need to move it around various orders/
        # subdirectories.
        #
        engine_orderid = broker_orderid_to_engine_orderid(broker_orderid)
        if engine_orderid is None:
            PYPWarn("[WARN] Order not found in engine orders, created outside?\n%s" %
                    (json.dumps(order, indent=4)))
            #ASSERT(False)
            continue

        placed_file = os.path.join(placed_dir, engine_orderid)
        partially_executed_file = os.path.join(partially_executed_dir, engine_orderid)
        executed_file = os.path.join(executed_dir, engine_orderid)
        squaredoff_file = os.path.join(squaredoff_dir, engine_orderid)
        cancelled_file = os.path.join(cancelled_dir, engine_orderid)
        failed_file = os.path.join(failed_dir, engine_orderid)

        # Can be in at most one of the above places.
        ASSERT((int(os.path.exists(placed_file)) +
                int(os.path.exists(partially_executed_file)) +
                int(os.path.exists(executed_file)) +
                int(os.path.exists(squaredoff_file)) +
                int(os.path.exists(failed_file))) <= 1)

        # Cannot be in cancelled_dir since it's not already cancelled.
        ASSERT(not os.path.exists(cancelled_file))

        #
        # Though we shouldn't call squareoff_all_open_intraday_orders() more
        # than once, but we do support that and simply ignore already
        # squaredoff orders.
        #
        if os.path.exists(squaredoff_file):
            PYPWarn("[auto-squareoff] ROBO order %s already in orders/squaredoff!" %
                    squaredoff_file)
            # We must correctly detect that order is already fully completed.
            ASSERT(cancelled and squaredoff)
            continue

        #
        # If the order was moved to failed_dir last time when we ran
        # auto-squaroff it'll still be in failed_dir, handle that.
        #
        if os.path.exists(failed_file):
            PYPWarn("[auto-squareoff] ROBO order %s already in orders/failed!" %
                    failed_file)
            # We must correctly detect that order is already fully completed.
            ASSERT(cancelled and squaredoff)
            continue

        #
        # Both cancelled and squaredoff True means that the order is already "fully
        # completed" and no squareoff was needed.
        #
        if cancelled and squaredoff:
            PYPInfo("[auto-squareoff] ROBO order already *fully completed*:\n%s" %
                    json.dumps(order, indent=4))
            #
            # Move it to executed_dir.
            # We can have following cases:
            # 1. It may already have been moved to executed_dir by
            #    refresh_orders()->move_to_correct_orders_dir().
            #    This will happen when the order was fully completed before
            #    the last time the periodic refresh_orders() ran.
            # 2. It may be in partially_executed_dir.
            #    This will happen when the order was fully completed after
            #    the last time the periodic refresh_orders() ran, but it was
            #    partially completed before that.
            # 3. It may be in placed_dir.
            #    This will happen when the order was fully completed after
            #    the last time the periodic refresh_orders() ran, and it was
            #    not even partially completed before that.
            #
            if os.path.exists(executed_file):
                PYPInfo("[auto-squareoff] ROBO order %s already in orders/executed!" %
                        executed_file)
                ASSERT(not os.path.exists(partially_executed_file))
                ASSERT(not os.path.exists(placed_file))
            elif os.path.exists(partially_executed_file):
                ASSERT(not os.path.exists(placed_file))
                try:
                    os.rename(partially_executed_file, executed_file)
                    PYPInfo("[PARTIALLY2FULLYEXECUTED] %s -> %s" %
                            (partially_executed_file, executed_file))
                except Exception as e:
                    PYPError("[PARTIALLY2FULLYEXECUTED] Failed to rename %s -> %s: %s" %
                            (partially_executed_file, executed_file, e))
            elif os.path.exists(placed_file):
                try:
                    os.rename(placed_file, executed_file)
                    PYPInfo("[PLACED2EXECUTED] %s -> %s" % (placed_file, executed_file))
                except Exception as e:
                    PYPError("[PLACED2EXECUTED] Failed to rename %s -> %s: %s" %
                            (placed_file, executed_file, e))
            else:
                # Has to be in one of the above dirs.
                ASSERT(False)
        elif squaredoff:
            # We squaredoff now, so cannot already be in executed_dir.
            ASSERT(not os.path.exists(executed_file))
            if os.path.exists(partially_executed_file):
                ASSERT(not os.path.exists(placed_file))
                try:
                    os.rename(partially_executed_file, squaredoff_file)
                    PYPInfo("[PARTIAL2SQUAREOFF] %s -> %s" %
                            (partially_executed_file, squaredoff_file))
                except Exception as e:
                    PYPError("[PARTIAL2SQUAREOFF] Failed to rename %s -> %s: %s" %
                            (partially_executed_file, squaredoff_file, e))
            elif os.path.exists(placed_file):
                try:
                    os.rename(placed_file, squaredoff_file)
                    PYPInfo("[PLACED2SQUAREDOFF] %s -> %s" %
                            (placed_file, squaredoff_file))
                except Exception as e:
                    PYPError("[PLACED2SQUAREDOFF] Failed to rename %s -> %s: %s" %
                            (placed_file, squaredoff_file, e))
            else:
                ASSERT(False)
        elif cancelled:
            #
            # Only an open BO order can be cancelled and if it's open it
            # cannot be in partially_executed_dir.
            #
            ASSERT(os.path.exists(placed_file))
            try:
                os.rename(placed_file, cancelled_file)
                PYPInfo("[PLACED2CANCELLED] %s -> %s" % (placed_file, cancelled_file))
            except Exception as e:
                PYPError("[PLACED2CANCELLED] Failed to rename %s -> %s: %s" %
                        (placed_file, cancelled_file, e))
        else:
            try:
                os.rename(placed_file, failed_file)
                PYPInfo("[PLACED2FAILED] %s -> %s" % (placed_file, failed_file))
            except Exception as e:
                PYPError("[PLACED2FAILED] Failed to rename %s -> %s: %s" %
                        (placed_file, failed_file, e))

def update_json(json_file, add_dict):
    ''' Given the path to a json file (which contains an engine order object), read
        the order object, add provided attributes and dump the updated order back into
        the same file.

        add_dict: Dictionary containing new attributes to be added to the json.
    '''
    try:
        # Read original.
        with open(json_file) as f:
            order = json.load(f)
            ASSERT_IS_VALID_ENGINE_ORDER(order)

        # Update.
        for k,v in add_dict.items():
            ASSERT(k not in order or (order[k] == v))
            order[k] = v

        # Write updated.
        with open(json_file, 'w') as f:
            json.dump(order, f, indent=4)

        PYPPass("Updated %s is:\n%s" % (json_file, json.dumps(order, indent=4)))

        #
        # Also update the engine orderbook to reflect this new order.
        # It may add the order in case of create, and update the state of the
        # existing order in case of cancel or modify.
        #
        update_engine_orderbook(order)
    except Exception as e:
        PYPError("update_json(%s, %s) failed: %s" % (json_file, add_dict, e))

def process_generated_order(orderid):
    ''' Process given order from generated_dir.

        XXX This is not entirely broker agnostic and has dependency on AngelOne.
    '''
    PYPInfo("process_generated_order(%s)" % orderid)

    # Absolute pathname of the order file.
    generated_file = os.path.join(generated_dir, orderid)

    # Generated order MUST be present in generated_dir.
    ASSERT(os.path.exists(generated_file))

    # MUST NOT be present in any other dir.
    placing_file = os.path.join(placing_dir, orderid)
    placed_file = os.path.join(placed_dir, orderid)
    partially_executed_file = os.path.join(partially_executed_dir, orderid)
    executed_file = os.path.join(executed_dir, orderid)
    squaredoff_file = os.path.join(squaredoff_dir, orderid)
    cancelled_file = os.path.join(cancelled_dir, orderid)
    failed_file = os.path.join(failed_dir, orderid)

    ASSERT(not os.path.exists(placing_file));
    ASSERT(not os.path.exists(placed_file));
    ASSERT(not os.path.exists(partially_executed_file));
    ASSERT(not os.path.exists(executed_file));
    ASSERT(not os.path.exists(squaredoff_file));
    ASSERT(not os.path.exists(cancelled_file));
    ASSERT(not os.path.exists(failed_file));

    #
    # Move the order to a temporary holding dir before placing the order with
    # the broker.
    # This is to make sure we never try to place an order twice, also it
    # results in less confusing logs if rename fails after placing the order.
    #
    # So, if we see an order in generated_dir that means we have not placed it
    # with the broker. If it's in placing_dir we would have attempted to place
    # it with the broker. If it's in placed_dir order placement succeeded and
    # if it's in failed_dir order placement failed.
    #
    try:
        os.rename(generated_file, placing_file)
        PYPInfo("[GEN2PLACING] %s -> %s" % (generated_file, placing_file))
    except Exception as e:
        PYPError("[GEN2PLACING] Failed to rename %s -> %s: %s" %
                (generated_file, placing_file, e))
        return

    #
    # Load the order json.
    # Though we should not fail to open the file but if we do, log an error
    # and return.
    #
    # XXX Inability to place order can have financial repercussions, so this
    #     should be treated seriously.
    #
    try:
        with open(placing_file) as f:
            order = json.load(f)
    except Exception as e:
        PYPError("[BUG] Failed to open/load %s with exception %s" % (placing_file, e))
        ASSERT(False)
        return

    PYPInfo("Got generated order: %s" % json.dumps(order, indent=4))

    ASSERT_IS_VALID_ENGINE_ORDER(order)
    # Filename must match the orderid member.
    ASSERT(str(order['orderid']) == orderid)

    ASSERT((order['action'] == "create") or
           (order['action'] == "modify") or
           (order['action'] == "cancel"));
    #
    # "broker_orderid" MUST be present for modify/cancel order and MUST NOT be
    # present for create orders.
    #
    ASSERT((order['action'] == "create") == ("broker_orderid" not in order))
    ASSERT(("broker_orderid" not in order) or (len(order["broker_orderid"]) > 0))

    ASSERT((order["producttype"] == "DELIVERY") or
           (order["producttype"] == "BO") or
           (order["producttype"] == "GTT"))

    #
    # Place order with broker.
    # We only support the following orders:
    # 1. GTT orders.
    #    These have producttype==GTT (and triggerprice>0).
    # 2. Delivery orders.
    #    These have producttype==DELIVERY (and triggerprice==0).
    # 3. Bracket orders.
    #    These have producttype==BO (and triggerprice==0).
    #
    # We have separate calls for placing regular orders and GTT orders.
    #
    is_gtt_order = (order["producttype"] == "GTT")
    is_delivery_order = (order["producttype"] == "DELIVERY")
    is_modify_order = (order['action'] == "modify")
    is_cancel_order = (order['action'] == "cancel")

    if is_gtt_order:
        #
        # If 'broker_orderid' attribute is set it must contain the GTT ruleid to be
        # modified or cancelled.
        #
        if is_modify_order:
            # Modify GTT orders MUST have triggerprice>0.
            ASSERT(order["triggerprice"] > 0)
            order_response = broker.modify_gtt(order)
            # Modify must confirm the same ruleid as requested, unless it fails.
            ASSERT((order_response is None) or
                   (order_response['orderid'] == order['broker_orderid']))
        elif is_cancel_order:
            # Cancel GTT orders MUST have triggerprice==0.
            ASSERT(order["triggerprice"] == 0)
            order_response = broker.cancel_gtt(order)
            # Cancel must confirm the same ruleid as requested, unless it fails.
            ASSERT((order_response is None) or
                   (order_response['orderid'] == order['broker_orderid']))
        else:
            # Create GTT orders MUST have triggerprice>0.
            ASSERT(order["triggerprice"] > 0)
            order_response = broker.create_gtt(order)
    else:
        # Currently we don't support modifying non-GTT orders.
        ASSERT(not is_modify_order)
        if is_cancel_order:
            variety = "ROBO" if order["producttype"] == "BO" else "NORMAL"
            order_response = broker.cancel_order(order['broker_orderid'], variety)
            # Cancel must confirm the same ruleid as requested, unless it fails.
            ASSERT((order_response is None) or
                   (order_response['orderid'] == order['broker_orderid']))
        else:
            order_response = broker.place_order(order)

    #
    # Order placement failed, move it to failed_dir and return.
    #
    if order_response is None:
        PYPError("Failed to %s %s%sorder from %s" %
                 ("cancel" if is_cancel_order else "place",
                  "MODIFY " if is_modify_order else "",
                  "GTT " if is_gtt_order else ("DELIVERY " if is_delivery_order else ""),
                  placing_file))
        try:
            os.rename(placing_file, failed_file)
            PYPInfo("[PLACING2FAILED] %s -> %s" % (placing_file, failed_file))
        except Exception as e:
            PYPError("[PLACING2FAILED] Failed to rename %s -> %s: %s" %
                    (placing_file, failed_file, e))
        return


    #
    # Order successfully placed.
    #

    # order_response MUST contain orderid.
    ASSERT('orderid' in order_response)

    #
    # order_response for GTT MUST NOT contain uniqueorderid and for
    # regular order it MUST contain uniqueorderid.
    #
    ASSERT(('uniqueorderid' in order_response) == (not is_gtt_order))

    b_orderid = order_response['orderid']
    b_uniqueorderid = ("" if is_gtt_order else order_response['uniqueorderid'])

    PYPPass("Successfully %s %s%sorder from %s: %s is %s" %
            ("cancelled" if is_cancel_order else "placed",
             "MODIFY " if is_modify_order else "",
             "GTT " if is_gtt_order else ("DELIVERY " if is_delivery_order else ""),
             placing_file,
             "ruleid" if is_gtt_order else "orderid",
             b_orderid))

    if is_cancel_order:
        try:
            os.rename(placing_file, cancelled_file)
            PYPInfo("[PLACING2CANCELLED] %s -> %s" % (placing_file, cancelled_file))

            #
            # Add broker's orderid to the json and few other attributes.
            # This will also update the engine_orderbook.
            #
            update_json(cancelled_file,
                        {
                            "broker_action": "cancelled",
                            "broker_timestamp": pd.Timestamp.now().timestamp(),
                            "broker_orderid": b_orderid,
                            "broker_uniqueorderid": b_uniqueorderid,
                        })
            #
            # Force an orderbook refresh, which will cause this
            # cancelled order to be reflected in orders/orderbook/.
            # orderbook is how OrderPlacer tells engine about status of orders
            # placed with the broker. engine monitors orderbook and updates
            # its incore orderbook based on order details added to this
            # directory.
            #
            refresh_orders_now()
        except Exception as e:
            PYPError("[PLACING2CANCELLED] Failed to rename %s -> %s: %s" %
                    (placing_file, cancelled_file, e))
            return
    else: # create or modify order.
        try:
            os.rename(placing_file, placed_file)
            PYPInfo("[PLACING2PLACED] %s -> %s" % (placing_file, placed_file))

            #
            # Add broker's orderid to the json and few other attributes.
            # This will also update the engine_orderbook.
            #
            # Note: If something goes wrong in update_json() and we crash then
            #       we won't be able to add the order to the engine_orderbook
            #       and also not update the broker_orderid and other
            #       attributes into the order. Such orders will be wrongly
            #       considered as "external order not placed by the engine".
            #
            update_json(placed_file,
                        {
                            "broker_action": "modified" if is_modify_order else "placed",
                            "broker_timestamp": pd.Timestamp.now().timestamp(),
                            "broker_orderid": b_orderid,
                            "broker_uniqueorderid": b_uniqueorderid,
                        })
            #
            # Force an orderbook refresh, which will cause this
            # new/updated order to be reflected in orders/orderbook/.
            # orderbook is how OrderPlacer tells engine about status of orders
            # placed with the broker. engine monitors orderbook and updates
            # its incore orderbook based on order details added to this
            # directory.
            #
            refresh_orders_now()
        except Exception as e:
            PYPError("[PLACING2PLACED] Failed to rename %s -> %s: %s" %
                    (placing_file, placed_file, e))
            return

def is_delivery_order(order_json):
    ''' Given a order json file tell whether it corresponds to a delivery order.
    '''
    with open(order_json, 'r') as f:
        order = json.load(f)
    return ((order['producttype'] == "DELIVERY") or
            (order['producttype'] == "GTT"))

def cleanup_orders():
    #
    # Cleanup various orders directories.
    # XXX Need to update orders/orderbook and handle DELIVERY orders.
    #

    #
    # Cleanup orders addressed with engine orderid.
    # All these directories have orders stored as engine orderid.
    #
    for d in [generated_dir, placing_dir, placed_dir, cancelled_dir, failed_dir,
              executed_dir, partially_executed_dir, squaredoff_dir]:
        order_files = os.listdir(d)
        PYPLog('Files found in %s: %s' % (d, order_files))

        # Filter probable order jsons.
        regex = re.compile('^[0-9]+$')
        order_files = list(filter(regex.search, order_files))

        for order_file in order_files:
            file_path = os.path.join(d, order_file)

            # Don't cleanup orders created today.
            if file_updated_after_market_start(file_path):
                continue

            if int(order_file) > MIN_ORDERID and is_delivery_order(file_path):
                continue

            old_path = os.path.join(d, "old", order_file)
            os.rename(file_path, old_path)
            PYPWarn("[cleanup_orders] %s -> %s" % (file_path, old_path))

    #
    # Cleanup orders addressed with broker orderid.
    #
    for d in [orderbook_dir, external_orders_dir]:
        order_files = os.listdir(d)
        PYPLog('Files found in %s: %s' % (d, order_files))

        #
        # Filter probable order jsons.
        # XXX We don't know what is a valid AngelOne brokerid, allow all.
        #     Till then allow only files starting with a number, this avoids
        #     directories like "old" to be counted as orders.
        #
        regex = re.compile('^[0-9]+')
        order_files = list(filter(regex.search, order_files))

        for order_file in order_files:
            file_path = os.path.join(d, order_file)

            # Don't cleanup orders created today.
            if file_updated_after_market_start(file_path):
                continue

            with open(file_path, 'r') as f:
                order = json.load(f)

            if order['producttype'] != "BO":
                continue

            old_path = os.path.join(d, "old", order_file)
            os.rename(file_path, old_path)
            PYPWarn("[cleanup_orders] %s -> %s" % (file_path, old_path))

    #
    # Misc.
    #
    # Note: We deliberately don't clean engine_orderbook so that we have
    #       engine<->broker orderid mappings for all orders not just today's
    #       orders. This will be required for non-intraday orders which we
    #       want engine<->broker orderid mapping for.
    #
    #       XXX See if we need it.
    #
    for file_path in [
                      #os.path.join(placed_dir, "engine_orderbook"),
                      os.path.join(orderbook_dir, "orderbook"),
                      os.path.join(orderbook_dir, "tradebook"),
                      os.path.join(account_dir, "funds"),
                      os.path.join(account_dir, "profile"),
                      os.path.join(positions_dir, "allpositions"),
                      os.path.join(holdings_dir, "allholdings")]:
        if os.path.exists(file_path):
            # Don't cleanup books created today.
            if file_updated_after_market_start(file_path):
                continue

            old_path = os.path.join(
                    os.path.dirname(file_path), "old", os.path.basename(file_path))
            os.rename(file_path, old_path)
            PYPWarn("[cleanup_orders] %s -> %s" % (file_path, old_path))

def watch_generated_dir():
    ''' Runner process for watching orders generated by the engine.
        It registers inotify events for the orders/generated directory
        and keeps listening for inotify events.
        On receiving an inotify event it calls the handler function for
        processing the order json.
    '''
    setproctitle.setproctitle("pylive.placer")

    #
    # It's very important to ensure that we don't have more than one instance
    # of this function running else all of them will try to place orders.
    #
    ensure_only_one_instance(cfg.pylivedir, "pylive.placer")

    #
    # Cleanup orders from orders/ directories.
    # This removes any stale orders.
    #
    cleanup_orders()

    PYPInfo('OrderPlacer: Runner, watching dir %s' % generated_dir)

    # Sit here fishing inotify events.
    for event in inotify_adapter.event_gen(yield_nones=False):
        (_, type_names, path, filename) = event

        ASSERT(path == generated_dir)

        #
        # XXX I've seen this fail when disk is not mounted,
        #     but this should not be running at 4:00 in the morning.
        #
        # Message: "[2023-12-01 04:07:11.745840][2678125][  INFO] Received ['IN_OPEN', 'IN_ISDIR'] event for /home/tomar/exploits/StockMarket/zerodha/bot/gitrepo/cppbacktester/src/pylive/orders/generated/"
        #
        # This could be because previous day pylive failed to stop, something
        # we don't expect, so if you see it pls raise it.
        #
        # Once we understand, remove this comment.
        #
        # Update: I haven't seen it for a long time now.
        #
        PYPInfo("Received %s event for %s/%s" % (type_names, path, filename))

        #
        # Safe to read the order json file only after it's completely written
        # and closed by the engine.
        #
        if 'IN_CLOSE_WRITE' not in type_names:
            continue

        #
        # Order files have names which are the orderid generated by the
        # engine, and those are numbers.
        #
        regex = re.compile('^[0-9]+$')
        if not regex.match(filename):
            PYPWarn("%s is not an order file, skipping!" % filename)
            continue

        #
        # Handle special orderids.
        #
        if int(filename) == squareoff_orderid:
            squareoff_all_open_intraday_orders()
        else:
            process_generated_order(filename)

def move_to_correct_orders_dir(order, orderbook):
    ''' Given 'order' from orderbook periodically fetched from broker, check whether
        and where this order needs to be moved into one of the pylive/orders/ subdirectory,
        and move it there.

        Note: This moves orders (delivery or bracket) to the appropriate directory
              to correctly reflect their current state.
              THIS DOES NOT MOVE GTT ORDERS. GTT orders always stay in orders/placed
              directory whether they are triggered or not.
              When GTT orders are triggered and hence placed with the Exchange,
              they result in a fresh order which we will come to know about from the
              holdings.
    '''
    #
    # order can be an order json returned as an element of orderbook, or a gtt
    # rule json returned as an element of gtt rule list.
    #
    is_gtt = broker.is_gtt_rule(order)

    # Every broker order MUST have these attributes.
    broker_orderid = order['orderid'] if not is_gtt else str(order['id'])
    uniqueorderid = order['uniqueorderid'] if not is_gtt else ""

    # Following gets engine_orderid for both orderid and gtt ruleid.
    engine_orderid = broker_orderid_to_engine_orderid(broker_orderid)

    #
    # If order wasn't placed by engine, don't need to move it around as
    # orders/ subdirectory only deals with orders generated by the engine.
    #
    # XXX Sometimes if OrderPlacer crashes half way when placing order and
    #     order does get placed at the broker but the engine_orderbook is not
    #     updated, then we won't be able to move that order correctly to
    #     orders/executed/partial f.e.
    #
    if engine_orderid is None:
        PYPWarn("Order not found in engine orderbook, "
                "probably placed outside?\n%s" %
                (json.dumps(order, indent=4)))
        return

    placed_file = os.path.join(placed_dir, engine_orderid)
    cancelled_file = os.path.join(cancelled_dir, engine_orderid)
    executed_file = os.path.join(executed_dir, engine_orderid)

    is_robo = broker.is_robo_main_order(order)
    if is_gtt:
        ASSERT(uniqueorderid == "")
        #
        # XXX Test and find out more about GTT status.
        #     f.e. How are NEW and ACTIVE different?
        #
        #     Update: I've not seen ACTIVE till now.
        #
        is_cancelled = (order['status'] == "CANCELLED")
        is_triggered = (order['status'] == "SENTTOEXCHANGE")
        if is_cancelled:
            # Once triggered, cannot be cancelled.
            ASSERT(not os.path.exists(executed_file))

            #
            # Cancelled GTT order, we have following possibilities:
            # 1. It is already present in cancelled_dir.
            # 2. It is present in placed dir.
            #
            if os.path.exists(cancelled_file):
                ASSERT(not os.path.exists(placed_file))
                return

            ASSERT(os.path.exists(placed_file))
            try:
                os.rename(placed_file, cancelled_file)
                PYPInfo("[PLACED2CANCELLED] %s -> %s" % (placed_file, cancelled_file))
            except Exception as e:
                PYPError("[PLACED2CANCELLED] Failed to rename %s -> %s: %s" %
                        (placed_file, cancelled_file, e))
        elif is_triggered:
            # Cancelled GTT cannot be triggered.
            ASSERT(not os.path.exists(cancelled_file))

            #
            # Triggered GTT order, we have following possibilities:
            # 1. It is already present in executed_dir.
            # 2. It is present in placed dir.
            #
            if os.path.exists(executed_file):
                ASSERT(not os.path.exists(placed_file))
                return

            ASSERT(os.path.exists(placed_file))
            try:
                os.rename(placed_file, executed_file)
                PYPInfo("[PLACED2EXECUTED] %s -> %s" % (placed_file, executed_file))
            except Exception as e:
                PYPError("[PLACED2EXECUTED] Failed to rename %s -> %s: %s" %
                        (placed_file, executed_file, e))
    elif is_robo:
        is_cancelled = (order['orderstatus'] == "cancelled")
        is_pe = broker.is_partially_completed_robo_order(broker_orderid, orderbook)
        is_fe = broker.is_fully_completed_robo_order(broker_orderid, orderbook)
        pe_file = os.path.join(partially_executed_dir, engine_orderid)
        fe_file = os.path.join(executed_dir, engine_orderid)

        if is_cancelled:
            #
            # Cancelled ROBO order, we have following possibilities:
            # 1. It is already present in cancelled_dir.
            # 2. It is present in placed dir.
            #
            # Note: Only an "open" ROBO order can be cancelled.
            #       Once it completes (partially) it cannot be cancelled, it
            #       can only either complete fully (one of the other legs
            #       completes) or it can be auto-squaredoff in which case the
            #       main order's orderstatus will be "complete".
            #
            ASSERT(not os.path.exists(pe_file))
            ASSERT(not os.path.exists(fe_file))

            if os.path.exists(cancelled_file):
                ASSERT(not os.path.exists(placed_file))
                return

            ASSERT(os.path.exists(placed_file))
            try:
                #
                # TODO: When we move the order to cancelled_dir, we must also
                #       set "broker_action" as cancelled.
                #       Also "broker_timestamp" should be updated from
                #       order["updatetime"].
                #       This has to be done for all order types and
                #       transitions.
                #
                os.rename(placed_file, cancelled_file)
                PYPInfo("[PLACED2CANCELLED] %s -> %s" % (placed_file, cancelled_file))
            except Exception as e:
                PYPError("[PLACED2CANCELLED] Failed to rename %s -> %s: %s" %
                        (placed_file, cancelled_file, e))
        elif is_fe:
            #
            # Fully executed order, we have following possibilities:
            # 1. It is already present in fully executed dir.
            # 2. It is present in partially executed dir.
            # 3. It is present in placed dir.
            #
            if os.path.exists(fe_file):
                ASSERT(not os.path.exists(pe_file))
                ASSERT(not os.path.exists(placed_file))
                return

            # partial -> fully executed.
            if os.path.exists(pe_file):
                ASSERT(not os.path.exists(placed_file))
                try:
                    os.rename(pe_file, fe_file)
                    PYPInfo("[PARTIALLY2FULLYEXECUTED] %s -> %s" % (pe_file, fe_file))
                except Exception as e:
                    PYPError("[PARTIALLY2FULLYEXECUTED] Failed to rename %s -> %s: %s" %
                            (pe_file, fe_file, e))
            else:
                # placed -> fully executed.
                ASSERT(os.path.exists(placed_file))
                try:
                    os.rename(placed_file, fe_file)
                    PYPInfo("[PLACED2FULLYEXECUTED] %s -> %s" % (placed_file, fe_file))
                except Exception as e:
                    PYPError("[PLACED2FULLYEXECUTED] Failed to rename %s -> %s: %s" %
                            (placed_file, fe_file, e))
        elif is_pe:
            #
            # Partially executed order, we have following possibilities:
            # 1. It is already present in partially executed dir.
            # 2. It is present in placed dir.
            #
            ASSERT(not os.path.exists(fe_file))
            if os.path.exists(pe_file):
                ASSERT(not os.path.exists(placed_file))
                return

            ASSERT(os.path.exists(placed_file))

            # placed -> partially executed.
            try:
                os.rename(placed_file, pe_file)
                PYPInfo("[PLACED2PARTIALLYEXECUTED] %s -> %s" % (placed_file, pe_file))
            except Exception as e:
                PYPError("[PLACED2PARTIALLYEXECUTED] Failed to rename %s -> %s: %s" %
                        (placed_file, pe_file, e))
    elif order['producttype'] == "DELIVERY": # DELIVERY
        if order['orderstatus'] == "complete":
            # Cancelled order cannot complete.
            ASSERT(not os.path.exists(cancelled_file))

            #
            # Completed delivery order, we have following possibilities:
            # 1. It is already present in executed dir.
            # 2. It is present in placed dir.
            #
            if os.path.exists(executed_file):
                ASSERT(not os.path.exists(placed_file))
                return

            # placed -> executed.
            ASSERT(os.path.exists(placed_file))
            try:
                os.rename(placed_file, executed_file)
                PYPInfo("[PLACED2EXECUTED] %s -> %s" % (placed_file, executed_file))
            except Exception as e:
                PYPError("[PLACED2EXECUTED] Failed to rename %s -> %s: %s" %
                        (placed_file, executed_file, e))
        elif order['orderstatus'] == "cancelled":
            # Executed order cannot be cancelled.
            ASSERT(not os.path.exists(executed_file))

            #
            # Cancelled delivery order, we have following possibilities:
            # 1. It is already present in cancelled_dir.
            # 2. It is present in placed dir.
            #
            # Note: Only an "open" delivery order can be cancelled.
            #       Once it completes it cannot be cancelled.
            #
            if os.path.exists(cancelled_file):
                ASSERT(not os.path.exists(placed_file))
                return

            # placed -> cancelled.
            ASSERT(os.path.exists(placed_file))
            try:
                os.rename(placed_file, cancelled_file)
                PYPInfo("[PLACED2CANCELLED] %s -> %s" % (placed_file, cancelled_file))
            except Exception as e:
                PYPError("[PLACED2CANCELLED] Failed to rename %s -> %s: %s" %
                        (placed_file, cancelled_file, e))
        else:
            ASSERT(order['orderstatus'] == "open")
    else:
        #
        # Only remaining orders are:
        # 1. ROBO sub-orders.
        #
        ASSERT(broker.is_robo_sub_order(order))

def refresh_portfolio():
    ''' Refresh portfolio details from AngelOne.
        It queries the following from AngelOne:
        - all holdings
        - all positions
        - funds

        This must be called periodically or after an order update from the broker,
        which might indicate some change in orders/holdings/positions.
    '''
    #
    # Query profile details and save it in pylive/orders/account/profile.
    # This needs to be done only once as profile information doesn't change.
    #
    global profileFetched
    if not profileFetched:
        profile = broker.get_profile()
        if profile is not None:
            profile_file = os.path.join(account_dir, "profile")
            try:
                with open(profile_file, 'w') as f:
                    json.dump(profile, f, indent=4)
                PYPInfo("Saved orders/account/profile:\n%s" % json.dumps(profile, indent=4))
                profileFetched = True
            except Exception as e:
                PYPError("Failed to save profile: %s" % e)
                ASSERT(False)

    #
    # Query fund details and save it in pylive/orders/account/funds.
    #
    funds = broker.get_funds()
    if funds is not None:
        funds_file = os.path.join(account_dir, "funds")
        try:
            with open(funds_file, 'w') as f:
                json.dump(funds, f, indent=4)
            PYPInfo("Saved orders/account/funds:\n%s" % json.dumps(funds, indent=4))
        except Exception as e:
            PYPError("Failed to save funds: %s" % e)
            ASSERT(False)

    #
    # Query holding details and save it in pylive/orders/holdings/allholdings.
    #
    holdings = broker.get_holdings()
    if holdings is not None:
        holdings_file = os.path.join(holdings_dir, "allholdings")
        try:
            with open(holdings_file, 'w') as f:
                json.dump(holdings, f, indent=4)
            PYPInfo("Saved orders/holdings/allholdings:\n%s" % json.dumps(holdings, indent=4))
        except Exception as e:
            PYPError("Failed to save holdings: %s" % e)
            ASSERT(False)

    #
    # Query position details and save it in pylive/orders/positions/allpositions.
    #
    positions = broker.get_positions()
    if positions is not None:
        positions_file = os.path.join(positions_dir, "allpositions")
        try:
            with open(positions_file, 'w') as f:
                json.dump(positions, f, indent=4)
            PYPInfo("Saved orders/positions/allpositions:\n%s" %
                    json.dumps(positions, indent=4))
        except Exception as e:
            PYPError("Failed to save positions: %s" % e)
            ASSERT(False)

def refresh_orders():
    ''' Refresh order status from AngelOne.
        It queries the following from AngelOne:
        - orders
        - GTTs

        This must be called periodically or after an order update from the broker,
        which might indicate some change in orders/holdings/positions.

        Note: This is the only function that places orders in orders/orderbook where
              engine reads from.
    '''
    #
    # Query orderbook and save it in pylive/orders/orderbook/orderbook.
    #
    orderbook = broker.get_order_book()
    if orderbook is not None:
        orderbook_file = os.path.join(orderbook_dir, "orderbook")
        try:
            with open(orderbook_file, 'w') as f:
                json.dump(orderbook, f, indent=4)
            PYPInfo("Saved orders/orderbook/orderbook:\n%s" % json.dumps(orderbook, indent=4))
        except Exception as e:
            PYPError("Failed to save orderbook: %s" % e)
            ASSERT(False)

    #
    # Query tradebook and save it in pylive/orders/orderbook/tradebook.
    #
    tradebook = broker.get_trade_book()
    if tradebook is not None:
        tradebook_file = os.path.join(orderbook_dir, "tradebook")
        try:
            with open(tradebook_file, 'w') as f:
                json.dump(tradebook, f, indent=4)
            PYPInfo("Saved orders/orderbook/tradebook:\n%s" % json.dumps(tradebook, indent=4))
        except Exception as e:
            PYPError("Failed to save tradebook: %s" % e)
            ASSERT(False)

    #
    # Query gttlist and save it in pylive/orders/gtt/gttlist.
    #
    gttlist = broker.get_gtt_list()
    if gttlist is not None:
        gttlist_file = os.path.join(gtt_dir, "gttlist")
        try:
            with open(gttlist_file, 'w') as f:
                json.dump(gttlist, f, indent=4)
            PYPInfo("Saved orders/gtt/gttlist:\n%s" % json.dumps(gttlist, indent=4))
        except Exception as e:
            PYPError("Failed to save gttlist: %s" % e)
            ASSERT(False)

    #
    # Go over all the orders from the freshly received orderbook and find
    # which ones have changed since the last time we saw them. The changed ones
    # have their json updated in pylive/orders/orderbook/{broker_orderid} so
    # that engine gets appropriately notified.
    #
    # XXX User may have cancelled the order from the app/portal. We should
    #     detect the orderstatus and move the orders appropriately to cancelled
    #     folder.
    #     Also orders may have completed with the Exchange, detect and move
    #     those to executed_dir.
    #
    global orderbook_dumpall_epoch

    #
    # Was engine or pylive.broker restarted after we dumped all the orders?
    # Is yes, then we should dump all orders (again) for engine to note.
    #
    dumpall = ((get_engine_startepoch() > orderbook_dumpall_epoch) or
               (get_pylivebroker_startepoch() > orderbook_dumpall_epoch))

    if orderbook is not None:
        orders = orderbook['data']
        if orders is not None:
            for order in orders:
                parentorderid = order['parentorderid']
                # Ignore sub-orders.
                if parentorderid != "":
                    continue

                #
                # Since we skip sub-orders we cannot get the target and
                # stoploss sub-orders.
                #
                ASSERT(not broker.is_robo_sub_order(order))

                #
                # Since we skip sub-orders each order will have a unique
                # broker_orderid and we save the order as that.
                #
                broker_orderid = order['orderid']
                uniqueorderid = order['uniqueorderid']
                engine_orderid = broker_orderid_to_engine_orderid(broker_orderid)
                order["engine_orderid"] = engine_orderid if engine_orderid else ""

                #
                # Add LTP details to the order.
                # Engine will use that to create the virtual candle on which
                # the order status changed, to be fed to the Account handlers.
                #
                # XXX Note that the order status may not have changed on this
                #     exact LTP, but unless we have lot of delay in processing
                #     order status, it should be fairly close.
                #
                token = order['symboltoken']
                ASSERT(len(token) > 1)
                symbol = broker.token_to_symbol(token)
                ASSERT(len(symbol) > 1)

                ltp = get_ltp(symbol)
                if ltp is not None:
                    order["ltp_sequence_number"] = ltp["sequence_number"]
                    order["ltp_timestamp"] = ltp["exchange_timestamp"]
                    order["ltp"] = ltp["last_traded_price"]
                else:
                    #
                    # This will usually not fail but in the start if we get
                    # some order detail from broker w/o getting any tick for
                    # that stock, we may have no LTP data. Those orders will
                    # not have the LTP data but anyways since it's the start
                    # those orders will not be acted upon by the engine so it's
                    # ok to have no LTP data.
                    #
                    #ASSERT(False)
                    order["ltp_sequence_number"] = 0
                    order["ltp_timestamp"] = 0
                    order["ltp"] = 0

                #
                # For orders placed by engine we would also want to move
                # the order to correct orders/ dir based on its current
                # status. Since we periodically call refresh_orders() it's
                # possible that the order is already moved to the required
                # orders/ directory, in that case don't do anything, else
                # look at the orderstatus and move the order to the
                # correct orders/ directory.
                #
                move_to_correct_orders_dir(order, orderbook)

                #
                # If this broker_orderid doesn't correspond to an order we
                # have placed, save it in orders/orderbook/external-orders/
                # also. This is just for the record.
                #
                if engine_orderid is None:
                    order_file = os.path.join(external_orders_dir, broker_orderid)
                    #
                    # Either dumpall is True or order_file doesn't exist, in
                    # both these cases we must dump this order.
                    #
                    update_json = (dumpall or (not os.path.exists(order_file)))
                    if not update_json:
                        with open(order_file, 'r') as f:
                            saved_order = json.load(f)
                            # order updatetime has changed.
                            update_json = (saved_order['updatetime'] != order['updatetime'])
                    if update_json:
                        with open(order_file, 'w') as f:
                            json.dump(order, f, indent=4)
                        PYPWarn("Saved external-order %s:\n%s" %
                                (order_file, json.dumps(order, indent=4)))

                #
                # The order status may have changed since last time we
                # created/updated in orders/orderbook/, update the order in
                # orders/orderbook/
                #
                order_file = os.path.join(orderbook_dir, broker_orderid)

                # Do we need to update the json file?
                update_json = False
                if (not dumpall) and os.path.exists(order_file):
                    try:
                        with open(order_file, 'r') as f:
                            saved_order = json.load(f)
                            # order updatetime has changed.
                            update_json = (saved_order['updatetime'] != order['updatetime'])
                    except Exception as e:
                        PYPError("Failed to load order from %s: %s" % (order_file, e))
                        ASSERT(False)
                else:
                    #
                    # Doesn't exist, or this is the first time after
                    # OrderPlacer startup.
                    # In both cases we must create the order to let engine
                    # know (all orders on startup and updated ones thereafter).
                    #
                    update_json = True

                if update_json:
                    try:
                        with open(order_file, 'w') as f:
                            json.dump(order, f, indent=4)
                        PYPInfo("Saved %s%s:\n%s" %
                                (order_file,
                                 " (first time after start)" if dumpall else "",
                                 json.dumps(order, indent=4)))
                    except Exception as e:
                        PYPError("Failed to save %s: %s" % (order_file, e))
                        ASSERT(False)

    #
    # TODO: Go over tradebook for executed orders.
    #

    #
    # Go over all the gtts from the freshly received gttlist and find
    # which ones have changed since the last time we saw them. The changed ones
    # have their json updated in pylive/orders/gtt/{ruleid} so
    # that engine gets appropriately notified.
    #
    if gttlist is not None:
        gtts = gttlist['data']
        if gtts is not None:
            for gtt in gtts:
                ruleid = str(gtt['id'])

                engine_orderid = broker_orderid_to_engine_orderid(ruleid)
                gtt["engine_orderid"] = engine_orderid if engine_orderid else ""

                #
                # Add LTP details to the gtt.
                # Engine will use that to create the virtual candle on which
                # the gtt status changed to be fed to the Account handlers.
                #
                # XXX Note that the gtt status may not have changed on this
                #     exact LTP, but unless we have lot of delay in processing
                #     gtt status, it should be fairly close.
                #
                token = gtt['symboltoken']
                ASSERT(len(token) > 1)
                symbol = broker.token_to_symbol(token)
                ASSERT(len(symbol) > 1)

                ltp = get_ltp(symbol)
                if ltp is not None:
                    gtt["ltp_sequence_number"] = ltp["sequence_number"]
                    gtt["ltp_timestamp"] = ltp["exchange_timestamp"]
                    gtt["ltp"] = ltp["last_traded_price"]
                else:
                    #
                    # This will usually not fail but in the start if we get
                    # some gtt detail from broker w/o getting any tick for
                    # that stock, we may have no LTP data. Those gtt will
                    # not have the LTP data but anyways since it's the start
                    # those gtt will not be acted upon by the engine so it's
                    # ok to have no LTP data.
                    #
                    #ASSERT(False)
                    gtt["ltp_sequence_number"] = 0
                    gtt["ltp_timestamp"] = 0
                    gtt["ltp"] = 0

                #
                # For gtts placed by engine we would also want to move
                # the gtt to correct orders/ dir based on its current
                # status. Since we periodically call refresh_orders() it's
                # possible that the order is already moved to the required
                # orders/ directory, in that case don't do anything, else
                # look at the orderstatus and move the order to the
                # correct orders/ directory.
                #
                move_to_correct_orders_dir(gtt, orderbook)

                #
                # If this ruleid doesn't correspond to an order we
                # have placed, save it in orders/orderbook/external-orders/
                # also. This is just for the record.
                #
                if engine_orderid is None:
                    gtt_file = os.path.join(external_orders_dir, ruleid)
                    with open(gtt_file, 'w') as f:
                        json.dump(gtt, f, indent=4)
                    PYPWarn("Saved external-gtt %s:\n%s" %
                            (gtt_file, json.dumps(gtt, indent=4)))

                gtt_file = os.path.join(gtt_dir, ruleid)
                # Do we need to update the json file?
                update_json = False
                if (not dumpall) and os.path.exists(gtt_file):
                    try:
                        with open(gtt_file, 'r') as f:
                            saved_gtt = json.load(f)
                            # gtt updatetime has changed.
                            update_json = (saved_gtt['updateddate'] != gtt['updateddate'])
                    except Exception as e:
                        PYPError("Failed to load gtt from %s: %s" % (gtt_file, e))
                        ASSERT(False)
                else:
                    # Doesn't exist, must create.
                    update_json = True

                if update_json:
                    try:
                        with open(gtt_file, 'w') as f:
                            json.dump(gtt, f, indent=4)
                        PYPInfo("Saved %s%s:\n%s" %
                                (gtt_file,
                                 " (first time after start)" if dumpall else "",
                                 json.dumps(gtt, indent=4)))
                    except Exception as e:
                        PYPError("Failed to save %s: %s" % (gtt_file, e))
                        ASSERT(False)
    #
    # Set orderbook_dumpall_epoch to current epoch.
    #
    # orderbook_dumpall_epoch MUST be in local timezone since we compare
    # it with engine's and pylive's starttick which is in local timezone.
    #
    if dumpall:
        orderbook_dumpall_epoch = int(
                        pd.Timestamp.now().tz_localize('Asia/Kolkata').timestamp())
        PYPInfo("orderbook_dumpall_epoch set to %d (%s)" %
                (orderbook_dumpall_epoch,
                pd.Timestamp(orderbook_dumpall_epoch, unit='s', tz='Asia/Kolkata')))
    # Either set above or already set.
    ASSERT(orderbook_dumpall_epoch > 0)


def refresh_data_from_broker():
    ''' Refresh thread that's called periodically and queries important info from
        (AngelOne) broker.
    '''
    global runner_stopped_gracefully
    global shall_refresh_orders_now

    # Keep running till stop() is called.
    while not runner_stopped_gracefully:
        # Fetch portfolio info.
        refresh_portfolio()
        # Fetch order info.
        refresh_orders()
        #
        # Fetch every 10 secs, but if refresh_orders_now() is called refresh
        # promptly.
        #
        for i in range(1, 100):
            time.sleep(0.1)
            if shall_refresh_orders_now:
                shall_refresh_orders_now = False
                refresh_orders()

def refresh_orders_now():
    global shall_refresh_orders_now
    shall_refresh_orders_now = True

def aso_at_305PM():
    ''' Auto-squareoff all open intraday orders at 03:05PM.
    '''
    global runner_stopped_gracefully

    # Keep running till stop() is called.
    while not runner_stopped_gracefully:
        if must_auto_squareoff_now():
            squareoff_all_open_intraday_orders()
            break
        time.sleep(10)
    ASSERT(not runner_stopped_gracefully)

def init():
    ''' This runs in the context of the main process.
    '''
    PYPInfo('OrderPlacer: init() start')

    #
    # Create empty placed/engine_orderbook if it doesn't already exist, so
    # that engine can place an inotify watch on it.
    #
    create_empty_engine_orderbook()

    # Initial call to refresh portfolio.
    refresh_portfolio()

    # Add inotify watcher for generated orders directory.
    global inotify_adapter
    inotify_adapter = inotify.adapters.Inotify()
    inotify_adapter.add_watch(generated_dir)

    #
    # Create a runner process for reading inotify events signalling new
    # generated orders and placing orders accordingly.
    #
    global runner
    runner = multiprocessing.Process(target=watch_generated_dir)
    ASSERT(runner is not None)

    global refresh_thread
    refresh_thread = threading.Thread(target=refresh_data_from_broker,
                                      args=(),
                                      daemon=False)
    refresh_thread.start()

    global aso_thread
    aso_thread = threading.Thread(target=aso_at_305PM,
                                  args=(),
                                  daemon=False)
    aso_thread.start()

    PYPInfo('OrderPlacer: init() end')

def start():
    ''' This runs in the context of the main process.
    '''
    PYPInfo('OrderPlacer: start() start')

    # init() must have created the runner. Start it now.
    ASSERT(runner is not None)
    runner.start()

    PYPInfo('OrderPlacer: start() end')

def stop():
    ''' This runs in the context of the main process.
    '''
    global runner_stopped_gracefully
    PYPInfo('OrderPlacer: stop() start')

    # stop() MUST be called after start().
    ASSERT(runner.pid != None)

    PYPWarn('Terminating OrderPlacer process %d' % (runner.pid))
    # stop() MUST be called only once.
    ASSERT(runner_stopped_gracefully == False)
    runner_stopped_gracefully = True
    runner.terminate()

    PYPInfo('OrderPlacer: stop() end')

def join():
    ''' This runs in the context of the main process.
    '''
    PYPInfo('OrderPlacer: join() start')

    # join() MUST be called after start().
    ASSERT(runner.pid != None)

    PYPWarn('Waiting for OrderPlacer process %d' % (runner.pid))
    runner.join()
    PYPWarn('OrderPlacer process %d completed with exitcode %d' %
            (runner.pid, runner.exitcode))
    #
    # If runner process fails due to some error, fail it to the
    # caller so that main program doesn't silently complete.
    # When we terminate the runner from stop() we kill it with a SIGTERM and
    # hence we don't treat that as a failure.
    #
    # XXX If we add more processes, need to call kill_all_children().
    #     See pyprocess/stockprocessor.py
    #
    if runner.exitcode != -(signal.SIGTERM):
        PYPError('%s FAILED (pid=%d) with exitcode %d' %
                        (runner.name, runner.pid, runner.exitcode))
        ASSERT(False)
    else:
        ASSERT(runner_stopped_gracefully)

    #
    # join() must be called after init().
    #
    ASSERT(refresh_thread is not None)
    refresh_thread.join()
    PYPInfo('CandleGenerator: refresh_thread exited!')

    ASSERT(aso_thread is not None)
    aso_thread.join()
    PYPInfo('CandleGenerator: aso_thread exited!')

    PYPInfo('OrderPlacer: join() end')
