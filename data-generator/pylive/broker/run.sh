#!/bin/bash

#
# This script is present in src/pylive/broker/.
# Following readlink is needed for correctly logging $srcdir in the error path.
#
SCRIPT_DIR="$(dirname $(readlink -f $0))"
srcdir="$SCRIPT_DIR/../.."
engine_dir="$srcdir/engine"
engine_config="$engine_dir/backtester.json"
pylive_dir="$(readlink -f $srcdir/pylive)"

if [ -z "$pylive_dir" ] || [ ! -d "$pylive_dir" ]; then
    echo "$srcdir/pylive not present!"
    echo "Make sure run.sh must be present in src/pylive/broker directory!"
    # systemd should not restart us, as restarting is not going to help.
    exit 0
fi

# engine/backtester.json is the fundamental config.
if [ ! -f "$engine_config" ]; then
    echo "$engine_config not present!"
    # systemd should not restart us, as restarting is not going to help.
    exit 0
fi

#
# "logdir" config from engine/backtester.json
# That's where live logs are created.
#
LOGDIR=$(cat $engine_config | egrep '^\s*"logdir"\s*:' | cut -d: -f2 | sed -e "s/^\s*//g" -e "s/\s*$//g" | tr -d ',"')
if [ -z "$LOGDIR" ]; then
    echo "logdir not defined in $engine_config!"
    # systemd should not restart us, as restarting is not going to help.
    exit 0
fi

#
# Following commonly happens when LOGDIR is on a removable media and
# that's not connected, bail out early in that case to avoid confusing logs
# later.
#
if [ ! -d "$LOGDIR" ]; then
    echo "$LOGDIR not present, bailing out!"
    # systemd should not restart us, as restarting is not going to help.
    exit 0
fi

#
# Create pylive/orders directories for holding orders in various stages of
# placement.
#
mkdir -p $pylive_dir/orders/{executed,failed,generated,placed,placing,squaredoff,ltp}
[ $? -eq 0 ] || echo "Failed to create pylive/orders directories!"

STATUS_FILE="$LOGDIR/status"

#
# XXX Don't clear logs here, pylive/cron/run.sh runs before this and clears
#     the logs.

if [ "$RUNNING_FROM_SYSTEMD" == "1" ]; then
        # Log on stdout too so that "systemctl status pylive-broker" can show it
        echo "[$(date)] Starting pylive/broker/main.py from systemd"
        echo "[$(date)] Starting pylive/broker/main.py from systemd" >> "$STATUS_FILE"
        $pylive_dir/broker/main.py
        ret=$?
        echo "[$(date)] pylive/broker/main.py exited with code $ret"
        echo "[$(date)] pylive/broker/main.py exited with code $ret" >> "$STATUS_FILE"
        #
        # If pylive exited abnormally it'll be restarted by systemd.
        # In that case we would want backtester to be restarted, to be safe.
        # This is needed as backtester has some state that depends on the
        # aggregate files generated by pylive (+ pyprocess). It asserts for
        # things like sizes of these live aggregate files should not go down.
        # Restarting pylive and not restarting engine may break some of these
        # asserts as engine is comparing data from the older incarnation of
        # pylive/broker with the new one. Though in an ideal world pylive
        # restarts should not change the generated aggregated files, but it
        # can happen since when pylive/broker is live it's generating
        # aggregate files from the $stock.live.csv files which are being
        # generated from the live ticks as they come. When restarted we query
        # those using historical APIs and they may differ slightly (some
        # decimal places may differ causing size to be different or maybe
        # something was missing in live ticks but in historical download it
        # shows up or vice versa. Some of these are signs of some other issues
        # with our code or AngelOne but those are practically seen).
        #
        if [ $ret -ne 0 ]; then
                echo "Killing engine!"
                killall -9 backtester
        fi
        exit $ret
else
        #
        # If not running from systemd we need to take care of restarting.
        #
        while :; do
                echo "[$(date)] Starting pylive/broker/main.py" >> "$STATUS_FILE"
                $pylive_dir/broker/main.py
                ret=$?
                echo "[$(date)] pylive/broker/main.py exited with code $ret" >> "$STATUS_FILE"
                # Break on successful exit.
                if [ $ret -eq 0 ]; then
                        break
                fi
        done
fi
